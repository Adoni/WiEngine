$#include "WiEngine.h"

enum wyTexture2D::TextAlignment {
	wyTexture2D::LEFT,
	wyTexture2D::CENTER,
	wyTexture2D::RIGHT
};

enum wyProgress::Style {
		/// sector in counter-clockwise
		wyProgress::RADIAL_CCW = 1,

		/// sector in clockwise
		wyProgress::RADIAL_CW,

		/// horizontal bar from left to right
		wyProgress::HORIZONTAL_BAR_LR,

		/// horizontal bar from right to left
		wyProgress::HORIZONTAL_BAR_RL,

		/// vertical bar from bottom to top
		wyProgress::VERTICAL_BAR_BT,

		/// vertical bar from top to bottom
		wyProgress::VERTICAL_BAR_TB
};

enum wyFontStyle {
	/// 正常字体
    NORMAL = 0,

    /// 粗体类型
    BOLD   = 0x01,

    /// 斜体类型
    ITALIC = 0x02,

    /// 粗斜体类型
    BOLD_ITALIC = 0x03
};

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyActionManager_h__


/**
 * @class wyActionManager
 *
 * 正在执行的动作管理类
 */
class wyActionManager : public wyObject {
public:
	/**
	 * 获得\link wyActionManager wyActionManager对象指针 \endlink
	 *
	 * @return \link wyActionManager wyActionManager对象指针 \endlink
	 */
	static wyActionManager* getInstance();

	/**
	 * 析构函数
	 */
	virtual ~wyActionManager();

	/**
	 * 启动动作并缓存动作到队列中，此方法中判断了是否已经添加过该动作，方法是线程安全的
	 *
	 * @param action 动作的\link wyAction wyAction对象指针\endlink
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 */
	void addActionLocked(wyAction* action, wyNode* target);

	/**
	 * 删除队列中的动作，方法是线程安全的
	 *
	 * @param action 动作的\link wyAction wyAction对象指针\endlink
	 */
	void removeActionLocked(wyAction* action);

	/**
	 * 根据执行动作节点和动作tag,删除队列中的动作,方法是线程安全的
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @param tag 动作的tag
	 */
	void removeActionByTagLocked(wyNode* target, int tag);

	/**
	 * 删除节点中所有动作,方法是线程安全的
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @param includeChildren 是否包含节点下的子节点
	 */
	void removeActionsLocked(wyNode* target, bool includeChildren);

	/**
	 * 删除所有动作
	 */
	void removeAllActionsLocked();

	/**
	 * 暂停一个动作
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @param tag 动作的tag
	 */
	void pauseActionLocked(wyNode* target, int tag);

	/**
	 * 恢复一个动作
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @param tag 动作的tag
	 */
	void resumeActionLocked(wyNode* target, int tag);
	
	/**
	 * 恢复执行节点中所有动作
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @param includeChildren 是否包含节点下的子节点
	 */
	void resumeActions(wyNode* target, bool includeChildren);

	/**
	 * 暂定执行节点中所有动作
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @param includeChildren 是否包含节点下的子节点
	 */
	void pauseActions(wyNode* target, bool includeChildren);
	
	/**
	 * 获得节点中正在实行的动作数量
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @return 节点中正在实行的动作数量
	 */
	int getRunningActionCount(wyNode* target);

	/**
	 * 根据执行动作节点和动作tag,返回动作\link wyAction wyAction对象指针\endlink
	 *
	 * @param target 执行动作的节点\link wyNode wyNode对象指针\endlink
	 * @param tag 动作的tag
	 * @return 动作\link wyAction wyAction对象指针\endlink
	 */
	wyAction* getAction(wyNode* target, int tag);

	/**
	 * 执行队列中的动作
	 *
	 * @param delta 距离上次动作执行的时间间隔
	 */
	void tick(float delta);

	/**
	 * 把有物理属性的节点添加到队列中进行统一维护, 这个方法不需要直接开发者直接调用
	 *
	 * @param node \link wyNode wyNode\endlink
	 */
	void addPhysicsNode(wyNode* node);

	/**
	 * 删除一个失去了物理属性的节点, 这个方法不需要直接开发者直接调用
	 *
	 * @param node \link wyNode wyNode\endlink
	 */
	void removePhysicsNode(wyNode* node);
};

#endif // __wyActionManager_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyArrayTileMapAtlas_h__


/**
 * @class wyArrayTileMapAtlas
 *
 * 实现了一个通过整型数组生成瓦片地图的机制。
 * 如果一个图片集包含3x3个单幅图片，则整数4会映射到第二行第二列的图片,因为 4 / 3 = 1, 4 % 3 = 1
 */
class wyArrayTileMapAtlas : public wyTileMapAtlas {
public:
	/**
	 * 静态构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param tileWidth 单个瓦片图片的宽度
	 * @param tileHeight 单个瓦片图片的高度
	 * @param xTiles x方向瓦片个数
	 * @param yTiles y方向瓦片个数
	 * @param tiles 原始瓦片值, 该数组会被复制，因此在构造完成后可以释放
	 */
	static wyArrayTileMapAtlas* make(wyTexture2D* tex, int tileWidth, int tileHeight, int xTiles, int yTiles, int* tiles);

	/**
	 * 构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param tileWidth 单个瓦片图片的宽度
	 * @param tileHeight 单个瓦片图片的高度
	 * @param xTiles x方向瓦片个数
	 * @param yTiles y方向瓦片个数
	 * @param tiles 原始瓦片值, 该数组会被复制，因此在构造完成后可以释放
	 */
	wyArrayTileMapAtlas(wyTexture2D* tex, int tileWidth, int tileHeight, int xTiles, int yTiles, int* tiles);

	/**
	 * 析构函数
	 */
	virtual ~wyArrayTileMapAtlas();

	/**
	 * 刷新瓦片值
	 */
	void refreshTileValues();

	/// @see wyTileMapAtlas::hasTileAt
    virtual bool hasTileAt(int x, int y);

    /// @see wyTileMapAtlas::getHorizontalTileCount
    virtual int getHorizontalTileCount() { return m_xTiles; }

    /// @see wyTileMapAtlas::getVerticalTileCount
    virtual int getVerticalTileCount() { return m_yTiles; }

    /// @see wyTileMapAtlas::tileValueAt
    virtual int tileValueAt(int x, int y);

    /**
	 * 得到原始瓦片值
	 *
	 * @return 原始瓦片值
	 */
    int* getTiles() { return m_tiles; }
};


#endif // __wyArrayTileMapAtlas_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyAtlasLabel_h__


class wyAtlasLabel;

/**
 * @class wyCharMap
 *
 * 维护一个字符与矩形的映射表，在构造\link wyAtlasLabel wyAtlasLabel\endlink 时，需要
 * 传入该类。
 */
class wyCharMap : public wyObject {

public:
    static wyCharMap* make();

    wyCharMap();
    virtual ~wyCharMap();

    /**
     * 映射矩形和字符
     *
     * @param rect 字符图片在图片集中的矩形
     * @param c 映射到的字符, 用整数表示字符的utf-8编码
     * @param leftPadding 字符左边应该保留的空隙
     * @param rightPadding 字符右边应该保留的空隙
     */
    void mapChar(wyRect rect, int c, float leftPadding = 0, float rightPadding = 0);

    /**
     * 映射矩形和字符
     *
     * @param frameName zwoptex中的帧名
     * @param c 映射到的字符, 用整数表示字符的utf-8编码
     * @param leftPadding 字符左边应该保留的空隙
     * @param rightPadding 字符右边应该保留的空隙
     */
    void mapChar(const char* frameName, int c, float leftPadding = 0, float rightPadding = 0);

    /**
     * 映射矩形和字符
     *
     * @param zwoptexName zwoptex名
     * @param frameName zwoptex中的帧名
     * @param c 映射到的字符, 用整数表示字符的utf-8编码
     * @param leftPadding 字符左边应该保留的空隙
     * @param rightPadding 字符右边应该保留的空隙
     */
    void mapChar(const char* zwoptexName, const char* frameName, int c, float leftPadding = 0, float rightPadding = 0);

	/**
	 * 设置一个空格的像素宽度
	 *
	 * @param w 空格的像素宽度
	 */
	void setSpaceWidth(float w) { m_spaceWidth = w; }

	/**
	 * 得到空格的像素宽度
	 *
	 * @return 空格的像素宽度
	 */
	float getSpaceWidth() { return m_spaceWidth; }

	/**
	 * 设置一个制表符代表的空格数目
	 *
	 * @param tabSize 一个制表符代表的空格数目
	 */
	void setTabSize(int tabSize) { m_tabSize = tabSize; }

	/**
	 * 得到一个制表符代表的空格数目
	 *
	 * @return 一个制表符代表的空格数目
	 */
	int getTabSize() { return m_tabSize; }
};

/**
 * @class wyAtlasLabel
 *
 * 图片集标签的封装,根据文字显示图片中的内容,效果可以实现各种字体
 */
class wyAtlasLabel : public wyNode {
public:
    /**
   	 * 静态构造函数
   	 *
   	 * @param text utf-8字符串
   	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
   	 * @param map \link wyCharMap wyCharMap\endlink
   	 */
    static wyAtlasLabel* make(const char* text, wyTexture2D* tex, wyCharMap* map);

    /**
	 * 析构函数
	 */
    virtual ~wyAtlasLabel();

	/// @see wyNode::getText
	virtual const char* getText() { return m_text; }

	/// @see wyNode::setText
	virtual void setText(const char* text);

	/**
	 * 设置行的宽度. 设置后节点的大小将被重新计算，因此节点大小可能会被改变。
	 *
	 * @param width 行宽, 如该值大于实际所有文字一行所占宽度，则行宽为实际宽度
	 */
	void setLineWidth(float width);

	/**
	 * 获得行的宽度
	 *
	 * @return 行宽
	 */
	float getLineWidth() { return m_lineWidth; }
};

#endif // __wyAtlasLabel_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyAtlasNode_h__


/**
 * @class wyAtlasNode
 *
 * 图片集节点的封装,是图片集节点的基类
 */
class wyAtlasNode : public wyNode {
public:
    /**
	 * 静态构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param itemWidth 图片块的宽度
	 * @param itemHeight 图片块的高度
	 * @param capacity 缓存数
	 */
    static wyAtlasNode* make(wyTexture2D* tex, int itemWidth, int itemHeight, int capacity);

    /**
	 * 构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param itemWidth 图片块的宽度
	 * @param itemHeight 图片块的高度
	 * @param capacity 缓存数
	 */
    wyAtlasNode(wyTexture2D* tex, int itemWidth, int itemHeight, int capacity);

    /**
	 * 析构函数
	 */
    virtual ~wyAtlasNode();
};

#endif // __wyAtlasNode_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyButton_h__


/**
 * @class wyButton
 *
 * 按钮的封装. 一个按钮有三个状态: 普通, 按下和禁止. 普通状态是必须要指定的, 其它
 * 两个状态可以没有. 这三个状态分别由三个\link wyNode wyNode\endlink 节点对象代表,
 * 因此按钮可以很灵活的由各种节点组成. 三个状态节点和按钮之间没有父子关系, 但是不影响
 * 这三个状态节点接收事件, 因为按钮在onEnter和onExit发生时也会调用它们的相应方法.
 */
class wyButton : public wyNode {
public:
	/**
	 * 静态构造函数
	 *
	 * @param normal 正常状态的\link wyNode wyNode对象指针 \endlink
	 * @param selected 被选中状态的\link wyNode wyNode对象指针 \endlink
	 * @param disabled 禁用状态的\link wyNode wyNode对象指针 \endlink
	 * @param focused  获得焦点状态的\link wyNode wyNode对象指针 \endlink
	 * @param downSelector 按下按钮的\link wyTargetSelector wyTargetSelector对象指针 \endlink
	 * @param upSelector 松开按钮的\link wyTargetSelector wyTargetSelector对象指针 \endlink
	 */
	static wyButton* make(wyNode* normal, wyNode* selected, wyNode* disabled, wyNode* focused, wyTargetSelector* downSelector, wyTargetSelector* upSelector);

	/**
	 * 构造函数
	 *
	 * @param normal 正常状态的\link wyNode wyNode对象指针 \endlink
	 * @param selected 被选中状态的\link wyNode wyNode对象指针 \endlink
	 * @param disabled 禁用状态的\link wyNode wyNode对象指针 \endlink
	 * @param focused  获得焦点状态的\link wyNode wyNode对象指针 \endlink
	 * @param downSelector 按下按钮的\link wyTargetSelector wyTargetSelector对象指针 \endlink
	 * @param upSelector 松开按钮的\link wyTargetSelector wyTargetSelector对象指针 \endlink
	 */
	wyButton(wyNode* normal, wyNode* selected, wyNode* disabled, wyNode* focused, wyTargetSelector* downSelector, wyTargetSelector* upSelector);

	/**
	 * 析构函数
	 */
	virtual ~wyButton();

	/**
	 * 设置正常状态的\link wyNode wyNode对象指针\endlink
	 *
	 * @param normal 正常状态的\link wyNode wyNode对象指针\endlink
	 */
	void setNormalState(wyNode* normal);

	/**
	 * 设置选中状态的\link wyNode wyNode对象指针\endlink
	 *
	 * @param selected 选中状态的\link wyNode wyNode对象指针\endlink
	 */
	void setSelectedState(wyNode* selected);

	/**
	 * 设置禁用状态的\link wyNode wyNode对象指针\endlink
	 *
	 * @param disabled 禁用状态的\link wyNode wyNode对象指针\endlink
	 */
	void setDisabledState(wyNode* disabled);

	/**
	 * 设置获得焦点状态的\link wyNode wyNode对象指针\endlink
	 *
	 * @param focused 获得焦点状态的\link wyNode wyNode对象指针\endlink
	 */
	void setFocusedState(wyNode* focused);

	/**
	 * 改变按钮的图片, 方便于一次修改按钮的图片
	 *
	 * @param normal 正常状态的贴图, 为NULL则不更新贴图
	 * @param selected 按下状态的贴图, 为NULL则不更新贴图
	 * @param disabled 禁止状态的贴图, 为NULL则不更新贴图
	 * @param focused  获得焦点状态的贴图, 为NULL则不更新贴图
	 */
	void setTexture(wyTexture2D* normal, wyTexture2D* selected, wyTexture2D* disabled, wyTexture2D* focused);
	
	/**
	 * 设置被点击时候的缩放比
	 *
	 * @param scale 被点击时候的缩放比
	 */
	void setClickScale(float scale) { m_clickScale = scale; }

	/**
	 * 得到被点击时候的缩放比
	 *
	 * @return 被点击时候的缩放比
	 */
	float getClickScale() { return m_clickScale; }
};

#endif // __wyButton_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyColorLayer_h__


/**
 * @class wyColorLayer
 *
 * 有底色显示层的封装
 */
class wyColorLayer : public wyLayer {
public:
	/**
	 * 静态构造函数
	 *
	 * @param color 颜色\link wyColor4B wyColor4B结构\endlink
	 */
	static wyColorLayer* make(wyColor4B color);

	/**
	 * 构造函数
	 *
	 * @param color 颜色\link wyColor4B wyColor4B结构\endlink
	 */
	wyColorLayer(wyColor4B color);

	/**
	 * 析构函数
	 */
	virtual ~wyColorLayer();

	/// @see wyNode::setContentSize
	virtual void setContentSize(float w, float h);

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_color.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha);

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);
	
	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);
};

#endif // __wyColorLayer_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyDirector_h__


// platform dependent

/**
 * @typedef wyProjectionType
 *
 * OpenGL投影方式
 */
typedef enum {
	/**
	 * 正交投影方式
	 */
	PROJECTION_2D = 1,

	/**
	 * 3D投影方式，fovy=60, znear=0.5f, zfar=1500.
	 */
	PROJECTION_3D,

	/**
	 * 自定义投影方式，用户需要自己调用OpenGL接口设置投影方式
	 */
	PROJECTION_CUSTOM
} wyProjectionType;

#define PROJECTION_DEFAULT PROJECTION_3D

/**
 * @typedef wySensorDelay
 *
 * 加速器事件触发速度级别
 */
typedef enum {
	/**
	 * 最快速度, 近似于每38毫秒一次事件
	 */
	DELAY_FASTEST,

	/**
	 * 较快速度, 近似于每62毫秒一次事件
	 */
	DELAY_GAME,

	/**
	 * 较慢速度, 近似于每104毫秒一次事件
	 */
	DELAY_UI,

	/**
	 * 最慢速度, 近似于每254毫秒一次事件
	 */
	DELAY_NORMAL
} wySensorDelay;

/**
 * @struct wyDirectorLifecycleListener
 *
 * Director生命周期监听器接口
 */
typedef struct wyDirectorLifecycleListener {
	/**
	 * 在Surface被创建的时候调用
	 *
	 * @param data 附加数据指针
	 */
	void (*onSurfaceCreated)(void* data);

	/**
	 * 在Surface改变的时候被调用
	 *
	 * @param w Surface新的宽度
	 * @param h Surface新的高度
	 * @param data 附加数据指针
	 */
	void (*onSurfaceChanged)(int w, int h, void* data);

	/**
	 * 在Surface销毁的时候调用
	 *
	 * @param data 附加数据指针
	 */
	void (*onSurfaceDestroyed)(void* data);

	/**
	 * 在Director的pause方法被调用后调用
	 *
	 * @param data 附加数据指针
	 */
	void (*onDirectorPaused)(void* data);

	/**
	 * 在Director的resume方法被调用后调用
	 *
	 * @param data 附加数据指针
	 */
	void (*onDirectorResumed)(void* data);

	/**
	 * 在Director中止的时候被调用
	 *
	 * @param data 附加数据指针
	 */
	void (*onDirectorEnded)(void* data);

	/**
	 * 在一个截屏被保存后调用
	 *
	 * @param path 截屏保存后的PNG图片路径
	 * @param data 附加数据指针
	 */
	void (*onDirectorScreenCaptured)(const char* path, void* data);
} wyDirectorLifecycleListener;

class wyDirector : public wyObject {
public:
	/**
	 * \if English
	 * get the singleton instance
	 *
	 * @return singleton of director
	 * \else
	 * 获得\link wyDirector wyDirector对象指针\endlink
	 *
	 * @return \link wyDirector wyDirector对象指针\endlink
	 * \endif
	 */
	static wyDirector* getInstance();
	
	/**
	 * \if English
	 * Get the singleton instance, but don't create it if not exist
	 * 
	 * @return singleton of director, or NULL if not created yet
	 * \else
	 * 得到director的单一实例, 但是如果实例尚未创建, 则不会自动创建
	 * 
	 * @return director的单一实例, 如果还没有创建, 返回NULL
	 * \endif
	 */
	static wyDirector* getInstanceNoCreate();

	/**
	 * \if English
	 * check whether the director is performing ending phase.
	 *
	 * @return true means the director is ending now, it is strong suggested that
	 * no engine-related operations be made during this phase.
	 * \else
	 * 检查是否Director正在结束中. 这个方法可以用来在某些不确定的情况下, 检查进行某个操作是否安全.
	 * 比如, 正准备调用一个方法, 但是这个时候可能程序正在退出, 正在退出意味着底层的对象可能正在处于
	 * 释放过程中或者已经释放, 如果不做检查就调用, 则可能因为调用一个已销毁对象而导致程序崩溃.
	 *
	 * @return true表示Director正在销毁, 在此期间最好不要再做任何事.
	 * \endif
	 */
	static bool isEnding();

	/**
	 * \if English
	 * Set a resource decoder used to decode obfuscated resource file. Director won't
	 * take care decoder lifecycle, you must release it if needed
	 *
	 * @param decoder \link wyResourceDecoder wyResourceDecoder\endlink implementation, NULL
	 * 		will disable resource decoding
	 * \else
	 * 设置一个资源解码器. Director不会负责释放解码器, 你必须自己处理
	 *
	 * @param decoder \link wyResourceDecoder wyResourceDecoder\endlink的具体实现, NULL
	 * 		表示取消资源解码器
	 * \endif
	 */
	static void setResourceDecoder(wyResourceDecoder* decoder);
	
	/**
	 * \if English
	 * Print all objects which is not released yet. It it a way to check
	 * possible object leak. For example, call it in a scene onEnter to check
	 * objects of previous scene are leaked or not.
	 * \else
	 * 打印当前还没有被释放的所有对象, 这可以用来检查内存泄露. 一般可以在一个场景的
	 * onEnter方法里调用这个方法查看前一个场景的对象是否都已经被释放
	 * \endif
	 */
	static void printUnreleasedObjects();

	/**
	 * \if English
	 * Print all memory blocks which is not released yet. The memory block
	 * must be allocated by WiEngine custom macro, such as wyMalloc, WYNEW etc.
	 * Otherwise the memory block can not be tracked.
	 *
	 * \note
	 * this method is only available for memory debug version. It just print a
	 * warning in release version
	 *
	 * @param fullLog true means including memory log in WiEngine, or false means just
	 * 		print memory log in app layer. default is false
	 * \else
	 * 打印所有还未分配的内存. 分配内存时必须使用WiEngine定义的宏, 如wyMalloc, WYNEW等.
	 * 否则分配的内存无法被跟踪
	 *
	 * \note
	 * 这个方法仅在内存调试版本中有效, 如果是正式发布的WiEngine版本, 仅打印一条警告
	 *
	 * @param fullLog true表示把WiEngine底层的未释放内存也都打印出来, false表示只打印
	 * 		应用层的未释放内存. 缺省是false
	 * \endif
	 */
	static void printUnreleasedMemory(bool fullLog = false);

	/**
	 * \if English
	 * Print memory usage summary. The memory block
	 * must be allocated by WiEngine custom macro, such as wyMalloc, WYNEW etc.
	 * Otherwise the memory block can not be tracked.
	 *
	 * \note
	 * this method is only available for memory debug version. It just print a
	 * warning in release version
	 * \else
	 * 打印出内存使用情况. 分配内存时必须使用WiEngine定义的宏, 如wyMalloc, WYNEW等.
	 * 否则分配的内存无法被跟踪
	 *
	 * \note
	 * 这个方法仅在内存调试版本中有效, 如果是正式发布的WiEngine版本, 仅打印一条警告
	 * \endif
	 */
	static void printMemoryUsage();

	/**
	 * \if English
	 * destructor
	 * \else
	 * 析构函数
	 * \endif
	 */
	virtual ~wyDirector();

	/**
	 * \if English
	 * set the surface view
	 *
	 * @param glView wyGLSurfaceView object
	 * \else
	 * 设置WYGLSurfaceView对象, 应该由java层调用。如果将WiEngine用于动态壁纸，则
	 * 这个方法不需要被调用。
	 *
	 * @param glView WYGLSurfaceView对象
	 * \endif
	 */
	virtual void attachInView(wyGLSurfaceView glView) = 0;

	/**
	 * \if English
	 * invoked from platform end, to set the context
	 *
	 * @param context platform dependent context object
	 * \else
	 * 设置特定平台的上下文对象
	 *
	 * @param context 特定平台的上下文对象
	 * \endif
	 */
	virtual void attachContext(wyGLContext context) = 0;

	/**
	 * \if English
	 * set the accelerometer level
	 *
	 * @param delay \link wySensorDelay wySensorDelay \endlink
	 * \else
	 * 设置加速器事件的触发速度, 目前有四个级别. 常量定义在wySensorDelay枚举中
	 *
	 * @param delay 触发速度, 可以是DELAY_FASTEST(最快),
	 * 		DELAY_GAME(较快), DELAY_UI(适合UI, 较慢),
	 * 		DELAY_NORMAL(最慢)
	 * \endif
	 */
	virtual void setAccelerometerDelay(wySensorDelay delay) = 0;

	/**
	 * \if English
	 * Invoked when surface is created
	 * \else
	 * Surface被创建时被调用
	 * \endif
	 */
	virtual void onSurfaceCreated();

	/**
	 * \if English
	 * Invoked when surface size is changed
	 *
	 * @param w new width of surface
	 * @param h new height of surface
	 * \else
	 * Surface大小发生变化时被调用
	 *
	 * @param w surface的新宽度
	 * @param h surface的新高度
	 * \endif
	 */
	virtual void onSurfaceChanged(int w, int h);

	/**
	 * \if English
	 * Invoked when surface is destroyed
	 * \else
	 * Surface被销毁时被调用
	 * \endif
	 */
	virtual void onSurfaceDestroyed();

	/**
	 * \if English
	 * set the screen adapting mode
	 *
	 * @param mode \link wyScaleMode wyScaleMode\endlink
	 * \else
	 * 设置屏幕适配模式. 这个方法必须要在surface创建之前调用.
	 *
	 * @param mode 屏幕适配模式
	 * \endif
	 */
	virtual void setScaleMode(wyScaleMode mode);

	/**
	 * \if English
	 * set the base size, this is the size where your games really lives in.
	 * Notice that this function must be called before creating surface.
	 *
	 * For more information about base size mode, read the tutorials
	 * \else
	 * 设置基础大小，仅当屏幕适配模式是基础大小适配模式时有效. 这个方法必须要在surface创建之前调用.
	 *
	 * @param w 游戏画面基础宽度
	 * @param h 游戏画面基础高度
	 * \endif
	 */
	virtual void setBaseSize(int w, int h);

	/**
	 * \if English
	 * pause the director. Once paused, the frame rendering, event dispatching are all paused.
	 * A common case is to call this function from android acticity's onPause()
	 * \else
	 * 暂停当前场景,返回true为设置成功,如果返回false说明已经是暂停状态，一般在android onPause事件中调用
	 * \endif
	 */
	bool pause();

	/**
	 * \if English
	 * resume the paused director
	 * \else
	 * 恢复当前场景,返回true为设置成功,如果返回false说明已经是恢复状态
	 * \endif
	 */
	bool resume();

	/**
	 * \if English
	 * get the window size
	 *
	 * @return \link wySize wySize\endlink
	 * \else
	 * 获得窗口尺寸\link wySize wySize结构\endlink
	 *
	 * @return \link wySize wySize结构\endlink
	 * \endif
	 */
	wySize getWindowSize();

	/**
	 * \if English
	 * get the window width, in pixels
	 * \else
	 * 获得窗口宽度
	 *
	 * @return 窗口宽度
	 * \endif
	 */
	int getWindowWidth();

	/**
	 * \if English
	 * get the window height
	 * \else
	 * 获得窗口高度
	 *
	 * @return 窗口高度
	 * \endif
	 */
	int getWindowHeight();

	/**
	 * \if English
	 * to add a life cycle listener
	 *
	 * @param l \link wyDirectorLifecycleListener wyDirectorLifecycleListener\endlink
	 * @param data user defined data
	 * \else
	 * 添加一个生命周期监听器
	 *
	 * @param l \link wyDirectorLifecycleListener wyDirectorLifecycleListener\endlink
	 * @param data 附加数据指针
	 * \endif
	 */
	void addLifecycleListener(const wyDirectorLifecycleListener* l, void* data);

	/**
	 * \if English
	 * getter, to get the surface view
	 * \else
	 * 获得WYGLSurfaceView对象
	 *
	 * @return WYGLSurfaceView对象
	 * \endif
	 */
	wyGLSurfaceView getGLView() { return m_glView; }
	
	/**
	 * \if English
	 * to get the context passed by attachContext
	 * \else
	 * 获得context对象
	 *
	 * @return 之前由attachContext传入的context
	 * \endif
	 */
	wyGLContext getContext() { return m_context; }

	/**
	 * \if English
	 * to set whether to display the FPS label
	 *
	 * @param show true means to display
	 * \else
	 * 设置是否显示FPS标签
	 *
	 * @param show true为显示
	 * \endif
	 */
	void setShowFPS(bool show);

	/**
	 * \if English
	 * Set flag indicating fps should be calculated or not, if true, you
	 * can retrieve current frame rate by \c getCurrentFrameRate. However,
	 * enable this feature will introduce a little cpu cost, but may be not
	 * much
	 *
	 * \note
	 * if you call setShowFPS(true), then it implied fps will be calculated
	 * \else
	 * 设置是否打开fps计算功能, 如果为true, 则可以通过\c getCurrentFrameRate获得当前
	 * 帧率. 但是打开这个功能肯定会消耗一些cpu资源, 但是应该不大.
	 *
	 * \note
	 * 如果调用了\c setShowFPS(true), 则fps计算也将打开
	 * \endif
	 */
	void setCalculateFPS(bool flag) { m_calculateFPS = flag; }

	/**
	 * \if English
	 * called to draw the next frame
	 * \else
	 * 该方法负责画下一帧场景
	 * \endif
	 */
	void drawFrame();

	/**
	 * \if English
	 * Set max frame rate
	 *
	 * @param maxFrameRate max frame rate
	 * \else
	 * 设置最大帧率
	 *
	 * @param maxFrameRate 最大帧率
	 * \endif
	 */
	void setMaxFrameRate(int maxFrameRate);

	/**
	 * \if English
	 * to run a scene
	 *
	 * @param scene \link wyScene wyScene \endlink
	 * \else
	 * 运行场景
	 *
	 * @param scene 需要运行的\link wyScene wyScene对象指针\endlink
	 * \endif
	 */
	void runWithScene(wyScene* scene);

	/**
	 * \if English
	 * pop the top from the stack, the next scene in the stack will become the active scene
	 * \else
	 * 弹出栈顶的场景, 切换到当前场景在栈中的上一个场景
	 * \endif
	 */
	void popScene();

	/**
	 * \if English
	 * perform scene transition from the current scene to the next scene in the stack
	 *
	 * @param trans \link wyTransitionScene wyTransitionScene\endlink
	 * \else
	 * 弹出栈顶的场景, 同时附带一个转场效果
	 *
	 * @param trans \link wyTransitionScene wyTransitionScene\endlink
	 * \endif
	 */
	void popSceneWithTransition(wyTransitionScene* trans);

	/**
	 * \if English
	 * push one scene to the stack, the pushed scene will become the active scene
	 *
	 * @param scene \link wyScene wyScene\endlink
	 * \else
	 * 切换场景,该方法会保留当前的场景在栈中,在下一场景按back键回回到当前场景
	 *
	 * @param scene 需要切换的\link wyScene wyScene对象指针\endlink
	 * \endif
	 */
	void pushScene(wyScene* scene);

	/**
	 * \if English
	 * replace the current active scene with the passed scene
	 *
	 * @param scene \link wyScene wyScene\endlink
	 * \else
	 * 切换场景,替换当前的运行场景,该方法不会保留当前的场景在栈中
	 *
	 * @param scene 需要切换的\link wyScene wyScene对象指针\endlink
	 * \endif
	 */
	void replaceScene(wyScene* scene);

	/**
	 * \if Englich
	 * Set checking texture flag so that all textures will be invalidate to make them reload
	 *
	 * @param flag true means all texture should be revalidate
	 * \else
	 * 设置检查贴图标志, 从而所有贴图都会被重新载入
	 *
	 * @param flag true表示所有贴图都会被重新载入
	 * \endif
	 */
	void setNeedCheckTexture(bool flag) { m_needCheckTexture = flag; }

	/**
	 * \if English
	 * to get the previous scene of the current scene
	 * \else
	 * 获得当前场景的上一个场景\link wyScene wyScene对象指针\endlink
	 *
	 * @return 当前场景的上一个场景\link wyScene wyScene对象指针\endlink
	 * \endif
	 */
	wyScene* getPreviousScene();

	/**
	 * \if English
	 * get the current scene
	 * \else
	 * 获得当前场景\link wyScene wyScene对象指针\endlink
	 *
	 * @return 当前场景\link wyScene wyScene对象指针\endlink
	 * \endif
	 */
	wyScene* getRunningScene() { return m_runningScene; }

	/**
	 * \if English
	 * get whether the director is paused
	 *
	 * @return true means paused
	 * \else
	 * 获得当前是否为暂停状态,true为暂停
	 *
	 * @return 当前暂停状态
	 * \endif
	 */
	bool isPaused() { return m_paused; }

	/**
	 * \if English
	 * get if the UI is paused
	 *
	 * @return true means UI is paused
	 * \else
	 * 获得当前是否被UI设置为暂停状态,true为暂停
	 *
	 * @return 当前暂停状态
	 * \endif
	 */
	bool isUIPaused() { return m_UIPaused; }

	/**
	 * \if English
	 * pause UI, once paused, all the running actions will stopped,
	 * but the event dispatching is still alive
	 * \else
	 * 暂停游戏，此方法只负责暂停游戏的调度器调度和动作管理，事件需要游戏实现者自行判断
	 * \endif
	 */
	void pauseUI() { m_UIPaused = true; }

	/**
	 * \if English
	 * resume UI from paused state
	 * \else
	 * 恢复游戏，此方法只负责恢复游戏的调度器调度和动作管理，事件需要游戏实现者自行判断
	 * \endif
	 */
	void resumeUI() { m_UIPaused = false; }

	/**
	 * \if English
	 * Get max frame rate. Zero means no limitation.
	 *
	 * @return max frame rate
	 * \else
	 * 得到允许的最大帧率, 游戏将确保以不超过该帧率的速度运行, 为0表示不限制
	 *
	 * @return 允许的最大帧率
	 * \endif
	 */
	int getMaxFrameRate() { return m_maxFrameRate; }

	/**
	 * \if English
	 * get the projection mode being used
	 * \else
	 * 返回当前的投影方式
	 *
	 * @return 当前的投影方式
	 * \endif
	 */
	wyProjectionType getProjection() { return m_projection; }

	/**
	 * \if English
	 * test whether a specified opengl extension is supported
	 *
	 * @param name name of the extension
	 * \else
	 * 测试是否某个OpenGL扩展被支持
	 *
	 * @param name 扩展名称
	 * \endif
	 */
	bool isExtensionSupported(const char* name);

	/**
	 * \if English
	 * check whether the surface has been created
	 *
	 * @return true means created
	 * \else
	 * 检查surface是否已经创建
	 *
	 * @return true表示surface已经创建，false表示没有或者已经被销毁
	 * \endif
	 */
	bool isSurfaceCreated() { return m_surfaceCreated; }

	/**
	 * \if English
	 * make a screen shot, the picture will be saved as a png file at
	 * the location specified by path.
	 *
	 * \par
	 * Notice:
	 * This function may not work on some devices of low configuration
	 * due to opengl supporting.
	 * With regard to iOS, the path to save the file is relative to
	 * the sand box of your application.
	 *
	 * @param path where to save the png file. The directory will be
	 * created automatically if not exist
	 * \else
	 * 抓取当前帧, 保存为png图片. 这个方法会将图片保存到指定路径，由于牵涉到文件
	 * 写操作, 因此速度较慢, 另外使用的OpenGL接口可能在低版本Android系统上没有
	 * 实现. 如果保存的路径在sd卡上, 则应用需要有写sd卡的权限.
	 *
	 * 在iOS平台上截图时, 传入的路径会被认为是相对于应用沙箱的Documents目录.
	 *
	 * @param path 截图保存的目标路径, 如果指定的路径不存在, 则会自动创建目录. 如果为NULL, 则不做任何事
	 * \endif
	 */
	void makeScreenshot(const char* path);

	/**
	 * \if English
	 * The only thing it is different from makeScreenshot(const char*) is that this function
	 * won't capture the full screen, it just capture the screen specified by rect.
	 *
	 * @param path see makeScreenshot(const char*)
	 * @param rect \link wyRect wyRect\endlink
	 * \else
	 * 抓取当前帧的一部分, 保存为png图片. 这个方法会将图片保存到指定路径，由于牵涉到文件
	 * 写操作, 因此速度较慢, 另外使用的OpenGL接口可能在低版本Android系统上没有
	 * 实现. 如果保存的路径在sd卡上, 则应用需要有写sd卡的权限.
	 *
	 * 在iOS平台上截图时, 传入的路径会被认为是相对于应用沙箱的Documents目录.
	 *
	 * @param path 截图保存的目标路径, 如果指定的路径不存在, 则会自动创建目录. 如果为NULL, 则不做任何事
	 * @param rect 需要截取的屏幕矩形范围
	 * \endif
	 */
	void makeScreenshot(const char* path, wyRect rect);

	/**
	 * \if English
	 * Be equal to calling makeScreenshot(path, node->getBoundingBoxRelativeToWorld)
	 *
	 * @param path see makeScreenshot(const char*)
	 * @param node \link wyNode wyNode\endlink
	 * \else
	 * 单独抓取某个节点范围内的内容, 节点范围会考虑到节点的缩放和旋转, 因此实际上是获得节点的
	 * getBoundingBoxRelativeToWorld的范围进行抓取.
	 *
	 * \note
	 * \c node的状态并不影响截图的结果, 因为只是获取\c node的矩形范围, 其它并无作用, 这个调用
	 * 实际上等同于makeScreenshot(path, node->getBoundingBoxRelativeToWorld())
	 *
	 * @param path 截图保存的目标路径, 如果指定的路径不存在, 则会自动创建目录. 如果为NULL, 则不做任何事
	 * @param node 需要抓取的节点
	 * \endif
	 */
	void makeScreenshot(const char* path, wyNode* node);

	/**
	 * \if English
	 * get the current frame rate
	 *
	 * @return the frame rate, per second
	 * \else
	 * 得到当前的帧率, 这个帧率其实是最近一次计算出的帧率, 因此不能说完全是当前的帧率. 不过基本和当前帧率是一致的.
	 *
	 * @return 最近的帧率
	 * \endif
	 */
	float getCurrentFrameRate() { return m_frameRate; }

	/**
	 * \if English
	 * check whether node has focus state
	 *
	 * @return true means enabled
	 * \else
	 * 检查节点是否具有焦点态
	 *
	 * @return true为可用
	 * \endif
	 */
	bool isFocusEnabled() { return m_focusEnabled; }

	/**
	 * \if English
	 * set whether to enable the node to have focus state, by default the focus state
	 * is disabled. One common case the focus state may be useful is a game operated by
	 * hard d-pad keyboard, where the player can easily know where the focus is now at and
	 * what would happen if he/she push down the OK key.
	 *
	 * @param flag true means to enable
	 * \else
	 * 设置节点是否具有焦点态, true为有, 缺省为false. 如果一个节点具有焦点态, 则其可以在获得输入焦点时
	 * 显示不同的样子. 这比较适合于某些需要通过实体键盘操作的游戏, 这样的话显示焦点态是有意义的. 对于无
	 * 实体键盘的机型, 焦点态的用处不明显, 因此可以根据您的需要设置是否打开这个功能. 如果这个标志是false,
	 * 则wyNode::setFocused方法没有任何效果. 如果是true, 则wyNode::setFocused会修改节点的焦点标志.
	 *
	 * @param flag 设置节点是否具有焦点态, true为可用
	 * \endif
	 */
	void setFocusEnabled(bool flag) { m_focusEnabled = flag; }

	/**
	 * \if English
	 * once the flag is set true, the time elapsed since the last frame will be set to zero.
	 * Normally, you don't need to call this function manually.
	 *
	 * The flag will be reset to false automatically by the engine.
	 *
	 * This just applies a occasion that some certain operations such as resource loading
	 * takes such a long time that the animation may miss its first few frames.
	 *
	 * @param flag
	 * \else
	 * 设置下一个delta时间是否为0. 这个方法会在每个场景载入后自动调用, 因此通常情况下您不需要调用此方法.
	 *
	 * @param flag true表示下一个delta时间设为0, 这主要用来避免因为资源载入导致的游戏体验不连续问题. 例如有一个场景中一开始就要执行动画,
	 * 			但是由于场景载入需要耗费一定时间, 因此可能导致动画的前面几帧被跳过. 那么可以设置这个标志强制使下一个delta时间为0, 这样
	 * 			动画将从第一帧开始.
	 * \endif
	 */
	void setNextDeltaTimeZero(bool flag) { m_nextDeltaTimeZero = flag; }

	/**
	 * \if English
	 * Set frame tick delta scaling factor, this can be used to control game
	 * total behavior. A smaller value than 1 will slow down game
	 * speed, or a larger value than one will speed up.
	 * \else
	 * 设置帧间隔的缩放因子, 这个方法可以用来控制游戏的整体运行速度. 如果该值比1小, 则
	 * 游戏整体上会呈现慢动作的状态, 如果比1大, 则整体呈现快动作. 1表示正常速度.
	 * \endif
	 */
	void setTickFactor(float r) { m_ttickFactor = r; }

	/**
	 * \if English
	 * Get frame tick scaling factor
	 * \else
	 * 得到帧间隔缩放因子
	 * \endif
	 */
	float getTickFactor() { return m_ttickFactor; }
};

#endif // __wyDirector_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyFrame_h__


/**
 * @class wyFrame
 *
 * 帧的封装,是所有帧类的基类
 */
class wyFrame : public wyObject {
public:
	/**
	 * 构造函数
	 *
	 * @param duration 持续的时间
	 */
	wyFrame(float duration);

	/**
	 * 析构函数
	 */
	virtual ~wyFrame();

	/**
	 * 获得帧持续的时间
	 *
	 * @return 帧持续的时间
	 */
	float getDuration() { return m_duration; }

	/**
	 * 设置帧持续时间
	 *
	 * @param duration 帧持续时间
	 */
	void setDuration(float duration) { m_duration = duration; }
};

#endif // __wyFrame_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyGradientColorLayer_h__


/**
 * @class wyGradientColorLayer
 *
 * 渐变色显示层的封装
 */
class wyGradientColorLayer : public wyLayer {
public:
	/**
	 * 静态构造函数
	 *
	 * @param fromColor 起始颜色\link wyColor4B wyColor4B结构\endlink
	 * @param toColor 结束颜色\link wyColor4B wyColor4B结构\endlink
	 * @param degree 渐变角度,0标识从左到右水平变化，大于0为顺时针
	 */
	static wyGradientColorLayer* make(wyColor4B fromColor, wyColor4B toColor, int degree);

	/**
	 * 构造函数
	 *
	 * @param fromColor 起始颜色\link wyColor4B wyColor4B结构\endlink
	 * @param toColor 结束颜色\link wyColor4B wyColor4B结构\endlink
	 * @param degree 渐变角度,0标识从左到右水平变化，大于0为顺时针
	 */
	wyGradientColorLayer(wyColor4B fromColor, wyColor4B toColor, int degree);

	/**
	 * 设置渐变角度
	 *
	 * @param degree 渐变角度
	 */
	void setDegree(int degree);

	/**
	 * 得到渐变角度
	 *
	 * @return 渐变角度
	 */
	int getDegree();

	/**
	 * 设置起始颜色
	 *
	 * @param color 起始颜色\link wyColor3B wyColor3B结构\endlink
	 */
	void setFromColor(wyColor3B color);

	/**
	 * 得到起始颜色
	 *
	 * @return 起始颜色\link wyColor3B wyColor3B结构\endlink
	 */
	wyColor3B getFromColor();

	/**
	 * 设置结束颜色
	 *
	 * @param color 结束颜色\link wyColor3B wyColor3B结构\endlink
	 */
	void setToColor(wyColor3B color);

	/**
	 * 得到结束颜色
	 *
	 * @return 结束颜色\link wyColor3B wyColor3B结构\endlink
	 */
	wyColor3B getToColor();

	/**
	 * 析构函数
	 */
	virtual ~wyGradientColorLayer();

	/// @see wyNode::setContentSize
	virtual void setContentSize(float w, float h);

};

#endif // __wyGradientColorLayer_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyLabel_h__


/**
 * @class wyLabel
 *
 * 标签的封装
 */
class wyLabel : public wyTextureNode {
public:
	/**
	 * 获得\link wyLabel wyLabel对象指针\endlink
	 *
	 * @param resId 标签上字符串的资源id
	 * @return \link wyLabel wyLabel对象\endlink
	 */
	static wyLabel* make(int resId);

	/**
	 * \if English
	 * factory function, used to create a new instance with autoRelease enabled
	 *
	 * @param resId the resource identifier of a string
	 * @param fontSize font size, in pixels
	 * @param fontPath path of the font to be used
	 * @param isFile true means \c fontPath is an absolute path in file system, false means
	 * 		\c fontPath is a relative path under assets
	 * @param width the width of the label, in pixels
	 * @param alignment text alignment, default is left
	 * \else
	 * 获得\link wyLabel wyLabel对象指针\endlink
	 *
	 * @param resId 标签上字符串的资源id
	 * @param fontSize 文字大小. 单位是像素.
	 * @param fontPath 字体文件路径
	 * @param isFile true表示\c fontPath是一个文件系统的绝对路径, false表示\c fontPath是一个相对于assets的相对路径
	 * @param width 文字的最大行宽，如果文字很长，则可能会折行成为多行标签. 单位是像素.
	 * @param alignment 文字对齐方式, 缺省是左对齐
	 * @return \link wyLabel wyLabel对象指针\endlink
	 * \endif
	 */
	static wyLabel* make(int resId, float fontSize, const char* fontPath, bool isFile = false, float width = 0, wyTexture2D::TextAlignment alignment = wyTexture2D::LEFT);

	/**
	 * \if English
	 * factory function, used to create a new instance with autoRelease enabled
	 *
	 * @param resId the resource identifier of a string
	 * @param fontSize font size, in pixels, so generally you need wrap this with SP macro to get a resolution independent behavior
	 * @param style font style, default is NORMAL
	 * @param fontName font name, defaul is NULL which means use system default font
	 * @param width the width of the label, in pixels
	 * @param alignment text alignment, default is left
	 * \else
	 * 获得\link wyLabel wyLabel对象指针\endlink
	 *
	 * @param resId 标签上字符串的资源id
	 * @param fontSize 文字大小. 单位是像素. 所以一般需要用SP宏来得到一个分辨率无关的字体大小
	 * @param style 字体样式, 缺省是NORMAL
	 * @param fontName 字体名称, 缺省是NULL, 表示使用缺省字体
	 * @param width 文字的最大行宽，如果文字很长，则可能会折行成为多行标签. 单位是像素.
	 * @param alignment 文字对齐方式, 缺省是左对齐
	 * @return \link wyLabel wyLabel对象指针\endlink
	 * \endif
	 */
	static wyLabel* make(int resId, float fontSize, wyFontStyle style = NORMAL, const char* fontName = NULL, float width = 0, wyTexture2D::TextAlignment alignment = wyTexture2D::LEFT);

	/**
	 * 获得\link wyLabel wyLabel对象指针\endlink
	 *
	 * @param text 显示内容的文字字符串
	 * @return \link wyLabel wyLabel对象指针\endlink
	 */
	static wyLabel* make(const char* text);

	/**
	 * \if English
	 * factory function, used to create a new instance with autoRelease enabled
	 *
	 * @param text null-terminated C string
	 * @param fontSize font size, in pixels
	 * @param fontPath path of the font to be used
	 * @param isFile true means \c fontPath is an absolute path in file system, false means
	 * 		\c fontPath is a relative path under assets
	 * @param width width of the Label, in pixels
	 * @param alignment text alignment, default is left
	 * \else
	 * 获得\link wyLabel wyLabel对象指针\endlink
	 *
	 * @param text 显示内容的文字字符串
	 * @param fontSize 文字大小. 单位是像素.
	 * @param fontPath 字体文件路径
	 * @param isFile true表示\c fontPath是一个文件系统的绝对路径, false表示\c fontPath是一个相对于assets的相对路径
	 * @param width 文字的最大行宽，如果文字很长，则可能会折行成为多行标签. 单位是像素.
	 * @param alignment 文字对齐方式, 缺省是左对齐
	 * @return \link wyLabel wyLabel对象指针\endlink
	 * \endif
	 */
	static wyLabel* make(const char* text, float fontSize, const char* fontPath, bool isFile = false, float width = 0, wyTexture2D::TextAlignment alignment = wyTexture2D::LEFT);

	/**
	 * \if English
	 * factory function, used to create a new instance with autoRelease enabled
	 *
	 * @param text null-terminated C string
	 * @param fontSize font size, in pixels, so generally you need wrap this with SP macro to get a resolution independent behavior
	 * @param style font style, default is NORMAL
	 * @param fontName font name, defaul is NULL which means use system default font
	 * @param width width of the label, in pixels
	 * @param alignment text alignment, default is left
	 * \else
	 * 获得\link wyLabel wyLabel对象指针\endlink
	 *
	 * @param text 显示内容的文字字符串
	 * @param fontSize 文字大小. 单位是像素. 所以一般需要用SP宏来得到一个分辨率无关的字体大小
	 * @param style 字体样式, 缺省是NORMAL
	 * @param fontName 字体名称, 缺省是NULL, 表示使用缺省字体
	 * @param width 文字的最大行宽，如果文字很长，则可能会折行成为多行标签. 单位是像素.
	 * @param alignment 文字对齐方式, 缺省是左对齐
	 * @return \link wyLabel wyLabel对象指针\endlink
	 * \endif
	 */
	static wyLabel* make(const char* text, float fontSize, wyFontStyle style = NORMAL, const char* fontName = NULL, float width = 0, wyTexture2D::TextAlignment alignment = wyTexture2D::LEFT);

	/**
	 * 析构函数
	 */
	virtual ~wyLabel();

	/**
	 * 获得文字字符串
	 *
	 * @return 文字字符串
	 */
	virtual const char* getText() { return m_tex->getText(); }

	/**
	 * 设置文字字符串
	 *
	 * @param text 文字字符串
	 */
	virtual void setText(const char* text);

	/**
	 * 通过一个字符串资源id设置标签文字
	 *
	 * @param resId 字符串资源id
	 */
	void setText(int resId);
	
	/**
	 * 设置字体大小
	 *
	 * @param fontSize 字体大小
	 */
	void setFontSize(float fontSize);

	/**
	 * 获得字体大小
	 */
	float getFontSize() { return m_fontSize; }

	/**
	 * 设置字体样式
	 *
	 * @param fontStyle 字体样式
	 */
	void setFontStyle(wyFontStyle fontStyle);

	/**
	 * 获得字体样式
	 */
	wyFontStyle getFontStyle() { return m_fontStyle; }

	/**
	 * 设置所用字体名字
	 *
	 * @param fontName 字体名字
	 */
	void setFontName(const char* fontName);

	/**
	 * 获得正在使用的字体名字
	 */
	const char* getFontName() { return m_fontName; }

	/**
	 * 设置字体路径
	 *
	 * fontPath 字体路径
	 */
	void setFontPath(const char* fontPath);

	/**
	 * 获得字体路径
	 */
	const char* getFontPath() { return m_fontPath; }	

	/**
	 * 设置标签宽度
	 */
	void setLineWidth(float lineWidth);

	/**
	 * 获得标签宽度
	 */
	float getLineWidth() { return m_lineWidth; }
};

#endif // __wyLabel_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyLayer_h__


/**
 * @class wyLayer
 *
 * 显示层的封装
 */
class wyLayer : public wyNode {
public:
	/**
	 * 静态构造函数
	 */
	static wyLayer* make();

	/**
	 * 构造函数
	 */
	wyLayer();

	/**
	 * 析构函数
	 */
	virtual ~wyLayer();
};

#endif // __wyLayer_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMenu_h__


#define DEFAULT_PADDING 5

/**
 * @class wyMenu
 *
 * 菜单显示层的封装
 */
class wyMenu : public wyLayer {
public:
	/**
	 * 静态构造函数
	 */
	static wyMenu* make();

	/**
	 * 静态构造函数
	 *
	 * @param item1 添加到菜单显示层中的\link wyMenuItem wyMenuItem对象指针\endlink,可以添加多个，以NULL结束
	 */
	static wyMenu* make(wyMenuItem* item1, ...);

	/**
	 * 构造函数
	 */
	wyMenu();

	/**
	 * 构造函数
	 *
	 * @param item1 添加到菜单显示层中的\link wyMenuItem wyMenuItem对象指针\endlink,可以添加多个，以NULL结束
	 */
	wyMenu(wyMenuItem* item1, ...);

	/**
	 * 析构函数
	 */
	virtual ~wyMenu();

	/// @see wyNode::touchesBegan
	virtual bool touchesBegan(wyMotionEvent& e);

	/// @see wyNode::touchesMoved
	virtual bool touchesMoved(wyMotionEvent& e);

	/// @see wyNode::touchesEnded
	virtual bool touchesEnded(wyMotionEvent& e);

	/// @see wyNode::touchesCancelled
	virtual bool touchesCancelled(wyMotionEvent& e);

	/// @see wyNode::hitTest
	virtual bool hitTest(float x, float y);

	/**
	 * 垂直排列菜单, 只排一列
	 *
	 * @param padding 菜单项垂直间隔
	 */
	void alignItemsVertically(float padding = DEFAULT_PADDING);

	/**
	 * 水平排列菜单, 只排一行
	 *
	 * @param padding 菜单项水平间隔
	 */
	void alignItemsHorizontally(float padding = DEFAULT_PADDING);

	/**
	 * 从第1行开始一直往下排列，每一行的列数通过参数指定. 每一行的列宽度是相等的。
	 *
	 * @param count columns数组的长度
	 * @param columns 每一行中的列数，比如{3, 2}，那么第一行会排3个，第二行会排2个
	 * @param padding 每行之间的间隔
	 */
	void alignItemsInColumns(int count, int* columns, float padding = DEFAULT_PADDING);

	/**
	 * 从第1列开始一直往右排列，每一列的行数通过参数指定. 每一列的行的高度是相等的.
	 *
	 * @param count rows数组的长度
	 * @param rows 每一列中的行数，比如{3, 2}，那么第一列会排3个，第二列会排2个
	 * @param padding 每列之间的间隔
	 */
	void alignItemsInRows(int count, int* rows, float padding = DEFAULT_PADDING);

	/**
	 * 添加一个菜单项\link wyMenuItem wyMenuItem对象指针\endlink
	 *
	 * @param item 添加到菜单显示层中的\link wyMenuItem wyMenuItem对象指针\endlink
	 */
	void addMenuItem(wyMenuItem* item);
};

#endif // __wyMenu_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMenuItem_h__


/**
 * 缺省菜单字体大小，单位是SP
 */
#define DEFAULT_FONT_SIZE 32

/**
 * 用于表示当前菜单的tag
 */
#define TAG_CURRENT_ITEM 0xc0c05001

/**
 * 用来表示缩放动作的tag，菜单点击时是有一个放大的效果的。
 */
#define TAG_ZOOM_ACTION 0xc0c05002

/**
 * @class wyMenuItem
 *
 * 菜单项的封装, 是所有菜单项的基类. 菜单项虽然是\link wyNode wyNode\endlink
 * 的子类, 但是却不会被添加到节点树中, 而是由\link wyMenu wyMenu\endlink 进行
 * 托管, 因此\link wyNode wyNode\endlink 中的一些生命周期方法是不会被调用的.
 */
class wyMenuItem : public wyNode {
public:
	/**
	 * 静态构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	static wyMenuItem* make(wyTargetSelector* downSelector, wyTargetSelector* upSelector);

	/**
	 * 构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	wyMenuItem(wyTargetSelector* downSelector, wyTargetSelector* upSelector);

	/**
	 * 析构函数
	 */
	virtual ~wyMenuItem();

	/**
	 * 当鼠标按下，移动，松开之前的回调
	 *
	 * @param ts 回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	virtual void beforeInvoke(wyTargetSelector* ts);
	
	/**
	 * 设置被点击时候的缩放比
	 *
	 * @param scale 被点击时候的缩放比
	 */
	void setClickScale(float scale) { m_clickScale = scale; }

	/**
	 * 得到被点击时候的缩放比
	 *
	 * @return 被点击时候的缩放比
	 */
	float getClickScale() { return m_clickScale; }
};

#endif // __wyMenuItem_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMenuItemAtlasLabel_h__


/**
 * @class wyMenuItemAtlasLabel
 *
 * 图片集标签菜单项的封装
 */
class wyMenuItemAtlasLabel : public wyMenuItem {
public:
	/**
	 * 静态构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param label 图片集标签\link wyAtlasLabel wyAtlasLabel对象指针\endlink
	 */
	static wyMenuItemAtlasLabel* make(wyTargetSelector* downSelector, wyTargetSelector* upSelector, wyAtlasLabel* label);

	/**
	 * 构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param label 图片集标签\link wyAtlasLabel wyAtlasLabel对象指针\endlink
	 */
	wyMenuItemAtlasLabel(wyTargetSelector* downSelector, wyTargetSelector* upSelector, wyAtlasLabel* label);

	/**
	 * 析构函数
	 */
	virtual ~wyMenuItemAtlasLabel();

	/// @see wyNode::setSelected
	virtual void setSelected(bool selected);

	/// @see wyNode::setEnabled
	virtual void setEnabled(bool enabled);

	/// @see wyMenuItem::beforeInvoke
	virtual void beforeInvoke(wyTargetSelector* ts);

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_normalColor.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha);

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);
	
	/**
	 * 设置禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 *
	 * @param color 禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 */
	void setDisabledColor(wyColor3B color);

	/**
	 * 得到禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 *
	 * @return 禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 */
	wyColor3B getDisabledColor();

	/**
	 * 设置图片集标签\link wyAtlasLabel wyAtlasLabel对象指针\endlink
	 *
	 * @param label 图片集标签\link wyAtlasLabel wyAtlasLabel对象指针\endlink
	 */
	void setLabel(wyAtlasLabel* label);
};

#endif // __wyMenuItemAtlasLabel_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMenuItemLabel_h__


/**
 * @class wyMenuItemLabel
 *
 * 标签菜单项的封装
 */
class wyMenuItemLabel : public wyMenuItem {
public:
	/**
	 * 静态构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param label 标签\link wyLabel wyLabel对象指针\endlink
	 */
	static wyMenuItemLabel* make(wyTargetSelector* downSelector, wyTargetSelector* upSelector, wyLabel* label);

	/**
	 * 构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param label 标签\link wyLabel wyLabel对象指针\endlink
	 */
	wyMenuItemLabel(wyTargetSelector* downSelector, wyTargetSelector* upSelector, wyLabel* label);

	/**
	 * 析构函数
	 */
	virtual ~wyMenuItemLabel();

	/// @see wyNode::setSelected
	virtual void setSelected(bool selected);

	/// @see wyNode::setEnabled
	virtual void setEnabled(bool enabled);

	/// @see wyMenuItem::beforeInvoke
	virtual void beforeInvoke(wyTargetSelector* ts);

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_normalColor.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha);

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);
	
	/**
	 * 设置标签\link wyLabel wyLabel对象指针\endlink
	 *
	 * @param label 标签\link wyLabel wyLabel对象指针\endlink
	 */
	void setLabel(wyLabel* label);

	/**
	 * 设置禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 *
	 * @param color 禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 */
	void setDisabledColor(wyColor3B color);

	/**
	 * 得到禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 *
	 * @return 禁用时的颜色\link wyColor3B wyColor3B结构\endlink
	 */
	wyColor3B getDisabledColor();
};

#endif // __wyMenuItemLabel_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMenuItemSprite_h__


/**
 * @class wyMenuItemSprite
 *
 * 图片对象菜单项的封装
 */
class wyMenuItemSprite : public wyMenuItem {
public:
	/**
	 * 静态构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param normal 正常状态图片对象\link wySprite wySprite对象指针\endlink
	 * @param selected 选中状态图片对象\link wySprite wySprite对象指针\endlink
	 * @param disabled 禁用状态图片对象\link wySprite wySprite对象指针\endlink
	 */
	static wyMenuItemSprite* make(wyTargetSelector* downSelector, wyTargetSelector* upSelector, wySprite* normal, wySprite* selected, wySprite* disabled);

	/**
	 * 构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param normal 正常状态图片对象\link wySprite wySprite对象指针\endlink
	 * @param selected 选中状态图片对象\link wySprite wySprite对象指针\endlink
	 * @param disabled 禁用状态图片对象\link wySprite wySprite对象指针\endlink
	 */
	wyMenuItemSprite(wyTargetSelector* downSelector, wyTargetSelector* upSelector, wySprite* normal, wySprite* selected, wySprite* disabled);

	/**
	 * 析构函数
	 */
	virtual ~wyMenuItemSprite();

	/// @see wyNode::draw
	virtual void setRotation(float rot);

	/// @see wyNode::setScale
	virtual void setScale(float scale);

	/// @see wyNode::setScaleX
	virtual void setScaleX(float scaleX);

	/// @see wyNode::setScaleY
	virtual void setScaleY(float scaleY);

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_normalState->getAlpha(); }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha);

	/// @see wyNode::getColor
	virtual wyColor3B getColor() { return m_normalState->getColor(); }

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);
	
	/// @see wyNode::setSelected
	virtual void setSelected(bool selected);

	/// @see wyNode::setEnabled
	virtual void setEnabled(bool enabled);

	/**
	 * 设置正常状态图片对象\link wySprite wySprite对象指针\endlink
	 *
	 * @param normal 正常状态图片对象\link wySprite wySprite对象指针\endlink
	 */
	void setNormalSprite(wySprite* normal);

	/**
	 * 得到正常状态\link wySprite wySprite对象指针\endlink
	 *
	 * @return 正常状态\link wySprite wySprite对象指针\endlink
	 */
	wySprite* getNormalSprite() { return m_normalState; }

	/**
	 * 设置选中状态图片对象\link wySprite wySprite对象指针\endlink
	 *
	 * @param selected 选中状态图片对象\link wySprite wySprite对象指针\endlink
	 */
	void setSelectedSprite(wySprite* selected);

	/**
	 * 得到选择状态\link wySprite wySprite对象指针\endlink
	 *
	 * @return 选择状态\link wySprite wySprite对象指针\endlink
	 */
	wySprite* getSelectedSprite() { return m_selectedState; }

	/**
	 * 设置禁用状态图片对象\link wySprite wySprite对象指针\endlink
	 *
	 * @param disabled 禁用状态图片对象\link wySprite wySprite对象指针\endlink
	 */
	void setDisabledSprite(wySprite* disabled);

	/**
	 * 得到禁止状态\link wySprite wySprite对象指针\endlink
	 *
	 * @return 禁止状态\link wySprite wySprite对象指针\endlink
	 */
	wySprite* getDisabledSprite() { return m_disabledState; }
};

#endif // __wyMenuItemSprite_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMenuItemToggle_h__


/**
 * @class wyMenuItemToggle
 *
 * Toggle菜单项，用于集成多个菜单项，每点击一次就切换到下一个菜单项，如果是最后一个菜单项，则切会第一个菜单项
 */
class wyMenuItemToggle : public wyMenuItem {
public:
	/**
	 * 静态构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param ... \link wyMenuItem wyMenuItem对象指针\endlink，可以为多个, 以NULL结束
	 */
	static wyMenuItemToggle* make(wyTargetSelector* downSelector, wyTargetSelector* upSelector, ...);

	/**
	 * 构造函数
	 *
	 * @param downSelector 按下菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param upSelector 松开菜单项的回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param ... \link wyMenuItem wyMenuItem对象指针\endlink，可以为多个, 以NULL结束
	 */
	wyMenuItemToggle(wyTargetSelector* downSelector, wyTargetSelector* upSelector, ...);

	/**
	 * 析构函数
	 */
	virtual ~wyMenuItemToggle();

	/// @see wyNode::setSelected
	virtual void setSelected(bool selected);

	/// @see wyNode::setEnabled
	virtual void setEnabled(bool enabled);

	/// @see wyMenuItem::beforeInvoke
	virtual void beforeInvoke(wyTargetSelector* ts);

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_color.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha);

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);
	
	/**
	 * 设置当前菜单项显示的位置
	 *
	 * @param index 当前菜单项显示的位置
	 */
	void setSelectedIndex(int index);

	/**
	 * 得到当前菜单项显示的位置
	 *
	 * @return 当前菜单项显示的位置
	 */
	int getSelectedIndex() { return m_selectedIndex; }

	/**
	 * 得到所有的菜单项数组
	 *
	 * @return \link wyArray wyArary\endlink
	 */
	wyArray* getMenuItems() { return m_items; }

	/**
	 * 添加一个菜单项\link wyMenuItem wyMenuItem对象指针\endlink
	 *
	 * @param item 菜单项\link wyMenuItem wyMenuItem对象指针\endlink
	 */
	void addMenuItem(wyMenuItem* item);
};

#endif // __wyMenuItemToggle_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMotionStreak_h__

/**
 * @typedef wyMotionStreakStyle
 *
 * motion streak中轨迹的样式常量
 */
typedef enum {
	/**
	 * 条状贴图带，连续，等宽，对应的ribbon子类是\link wyStripRibbon wyStripRibbon\endlink
	 */
	MS_STYLE_STRIP,

	/**
	 * 点状贴图带，不连续，一次全图显示, 类似愤怒小鸟的轨迹效果，对应的ribbon
	 * 子类是\link wySpotRibbon wySpotRibbon\endlink
	 */
	MS_STYLE_SPOT,

	/**
	 * 刀痕状，连续，不等宽，类似于水果忍者的效果，对应的ribbon类是\link wyBladeRibbon wyBladeRibbon\endlink
	 */
	MS_STYLE_BLADE,
	
	/**
	 * 连续的线段, 用来渲染一条粗线, 对应的ribbon类是\link wyLineRibbon wyLineRibbon\endlink.
	 * 该式样不支持淡出效果.
	 */
	MS_STYLE_LINE
} wyMotionStreakStyle;

/**
 * @class wyMotionStreak
 *
 * 动作跟踪对象。动作跟踪对象使用\link wyRibbon wyRibbon\endlink来显示动作的轨迹。 你可以控制Ribbon的淡出时间，
 * 段大小，贴图路径，贴图长度和颜色等来控制轨迹的样式
 */
class wyMotionStreak : public wyNode {
public:
	/**
	 * 创建位置跟踪对象. 位置之间的轨迹以指定贴图画出, 轨迹的宽度和贴图宽度一致.
	 *
	 * @param fade Ribbon段的淡出时间, 传入0表示不淡出一直保持，直到用reset清除
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图的颜色
	 * @param style motion streak轨迹的样式，缺省是条状
	 */
	static wyMotionStreak* make(float fade, wyTexture2D* tex, wyColor4B color, wyMotionStreakStyle style = MS_STYLE_STRIP);

	/**
	 * 创建位置跟踪对象. 位置之间的轨迹以指定贴图画出, 轨迹的宽度和贴图宽度一致.
	 *
	 * @param fade Ribbon段的淡出时间, 传入0表示不淡出一直保持，直到用reset清除
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图的颜色
	 * @param style motion streak轨迹的样式，缺省是条状
	 */
	wyMotionStreak(float fade, wyTexture2D* tex, wyColor4B color, wyMotionStreakStyle style = MS_STYLE_STRIP);

	/**
	 * 析构函数
	 */
	virtual ~wyMotionStreak();

	/// @see wyNode::getTexture
	virtual wyTexture2D* getTexture() { return m_ribbon->getTexture(); }

	/// @see wyNode::setTexture
	virtual void setTexture(wyTexture2D* tex) { m_ribbon->setTexture(tex); }

	/**
	 * 获得包含的\link wyRibbon wyRibbon\endlink 对象
	 *
	 * @return \link wyRibbon wyRibbon\endlink
	 */
	wyRibbon* getRibbon() { return m_ribbon; }

	/**
	 * 得到上一个点的位置, 为全局坐标. 如果返回的坐标是(-1, -1), 说明lastLocation还不存在，
	 * 有可能motion streak处于一个新线段的开始，还没有超过两个点，所以并无线段存在。
	 *
	 * @return \link wyPoint wyPoint\endlink
	 */
	wyPoint getLastLocation() { return m_lastLocation; }

	/**
	 * 得到当前点的位置, 为全局坐标, 如果返回的坐标是(-1, -1), 说明当前点还不存在，也就是对于
	 * 当前线段来说，一个点也没有。
	 *
	 * @return \link wyPoint wyPoint\endlink
	 */
	wyPoint getCurrentLocation() { return m_currentLocation; }

	/**
	 * 设置暂停更新标志
	 *
	 * @param flag true表示暂停更新streak
	 */
	void setPaused(bool flag) { m_paused = flag; }

	/**
	 * 得到暂停更新标志
	 *
	 * @return true表示暂停更新streak
	 */
	bool isPaused() { return m_paused; }
	
	/**
	 * 添加一个点到轨迹中
	 *
	 * @param x 点的x值，这个值是相对于\link wyMotionStreak wyMotionStreak\endlink自身位置的
	 * @param y 点的y值，这个值是相对于\link wyMotionStreak wyMotionStreak\endlink自身位置的
	 * @param newSegment true表示强制结束当前分段，另起一个分段。另起一个分段的意思试在一个新
	 * 		的位置开始渲染，而不是上一个位置自动和新位置连接。缺省是false
	 */
	void addPoint(float x, float y, bool newSegment = false);
	
	/**
	 * 重置，立刻清除当前所有的轨迹点, 回到初始状态
	 */
	void reset();

	/**
	 * motion streak中轨迹渲染的样式
	 *
	 * @return 样式常量
	 */
	wyMotionStreakStyle getStyle() { return m_style; }
	
	/**
	 * 设置段阈值
	 *
	 * @param threshold 段阈值
	 */
	void setSegmentThreshold(float threshold) { m_segThreshold = threshold; }

	/**
	 * 得到段阈值
	 *
	 * @return 段阈值
	 */
	float getSegmentThreshold() { return m_segThreshold; }
};

#endif // __wyMotionStreak_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyMultiplexLayer_h__


/**
 * @class wyMultiplexLayer
 *
 * 多显示层的封装
 */
class wyMultiplexLayer : public wyLayer {
public:
	/**
	 * 静态构造函数
	 */
	static wyMultiplexLayer* make();

	/**
	 * 构造函数
	 */
	wyMultiplexLayer();

	/**
	 * 析构函数
	 */
	virtual ~wyMultiplexLayer();

	/**
	 * 添加显示层
	 *
	 * @param layer 被添加的显示层\link wyLayer wyLayer对象指针\endlink
	 */
	void addLayer(wyLayer* layer);

	/**
	 * 根据索引删除显示层
	 *
	 * @param index 被删除的显示层索引
	 */
	void removeLayer(int index);

	/**
	 * 切换显示层
	 *
	 * @param index 启动的显示层索引
	 */
	void switchTo(int index);

	/**
	 * 得到当前启用的显示层索引
	 *
	 * @return 当前启用的显示层索引
	 */
	int getEnabledLayer() { return m_enabledLayer; }
};

#endif // __wyMultiplexLayer_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyNinePatchSprite_h__


/**
 * @class wyNinePatchSprite
 *
 * 点9精灵图片对象. 可以对一个图片指定一个可缩放区域, 这样一个小图片可以被缩放
 * 为任意大小. 这类似于Android提供的.9图片格式, 不过并不支持不连续的缩放区域.
 *
 * 目前wyNinePatchSprite不支持旋转过的图片集图片, 即rotated属性为true的图片集
 * 图片尚不支持
 */
class wyNinePatchSprite : public wyNode {
public:
	/**
	 * 构造\link wyNinePatchSprite wyNinePatchSprite对象指针\endlink
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 * @param patchRect 图片中被拉伸的矩形区域, 坐标相对于图片, 以图片的左上角为原点
	 * @return \link wyNinePatchSprite wyNinePatchSprite对象指针\endlink
	 */
	static wyNinePatchSprite* make(wyTexture2D* tex, wyRect patchRect);

	/**
	 * 构造\link wyNinePatchSprite wyNinePatchSprite对象指针\endlink
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 * @param texRect 如果tex代表了一个图片集, 则可以通过\c texRect 指定图片集中的图片矩形
	 * @param patchRect 图片中被拉伸的矩形区域, 坐标相对于图片, 以图片的左上角为原点
	 * @return \link wyNinePatchSprite wyNinePatchSprite对象指针\endlink
	 */
	static wyNinePatchSprite* make(wyTexture2D* tex, wyRect texRect, wyRect patchRect);

	/**
	 * 析构函数
	 */
	virtual ~wyNinePatchSprite();

	/// @see wyNode::setContentSize
	virtual void setContentSize(float w, float h);

	/// @see wyNode::getTexture
	virtual wyTexture2D* getTexture();

	/// @see wyNode::setTexture
	virtual void setTexture(wyTexture2D* tex);

	/**
	 * 指定所使用的贴图区域, 同时改变图片大小为当前贴图区域大小, 单位为像素.
	 * 贴图区域默认为整张图片,如需改变则调用此函数.
	 *
	 * @param[in] rect 矩形，(rect.x, rect.y)为左上角
	 */
	void setTextureRect(wyRect rect);

	/**
	 * 获得当前所使用的贴图区域,单位为像素.
	 *
	 * @return 矩形，(rect.x, rect.y)为左上角
	 */
	wyRect getTextureRect() { return m_texRect; }
};

#endif // __wyNinePatchSprite_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyNode_h__


#define INVALID_TAG -1

class wyNode;

/**
 * @struct wyNodePositionListener
 *
 * 用来监听节点位置变化的回调接口, 当setPosition方法被调用时, 这个
 * 回掉会被触发
 */
typedef struct wyNodePositionListener {
	/**
	 * 当位置变化时, 该方法被调用
	 *
	 * @param node \link wyNode wyNode\endlink
	 * @param data 附加数据指针
	 */
	void (*onPositionChanged)(wyNode* node, void* data);
} wyNodePositionListener;

/**
 * @class wyNode
 *
 * 节点对象的封装,是所有节点的基类
 */
class wyNode : public wyObject {

public:
	/**
	 * 静态构造函数
	 */
	static wyNode* make();

	/**
	 * 当节点要变成活动态时，该方法被调用。活动态即节点所属的场景正在运行。
	 * 该方法由WiEngine内部调用，不需要手动调用
	 */
	virtual void onEnter();

	/**
	 * 当节点所属场景退出时该方法被调用，或者当该节点被删除时被调用
	 * 该方法由WiEngine内部调用，不需要手动调用
	 */
	virtual void onExit();

	/**
	 * 当节点所属场景切换完成时该方法被调用
	 * 该方法由WiEngine内部调用，不需要手动调用
	 */
	virtual void onEnterTransitionDidFinish();

	/**
	 * 当节点被添加到某个父节点后，该方法被调用. 这个方法会发生在onEnter之前.
	 */
	virtual void onAttachToParent(wyNode* parent);

	/**
	 * 当节点从某个父节点删除之前，该方法被调用，这个方法会发生在onExit之前
	 */
	virtual void onDetachFromParent(wyNode* parent);

	/**
	 * 重置节点状态，包括子节点的状态
	 */
	virtual void cleanup();
	
	/**
	 * \if English
	 * Set anchor relative position
	 *
	 * @param x relative x position
	 * @param y relative y position
	 * \else
	 * 设置锚点的相对位置
	 *
	 * @param x 相对x位置
	 * @param y 相对y位置
	 * \endif
	 */
	virtual void setAnchor(float x, float y);

	/**
	 * \if English
	 * Set anchor relative x position
	 *
	 * @param x relative x position
	 * \else
	 * 设置锚点的x位置
	 *
	 * @param x 相对x位置
	 * \endif
	 */
	virtual void setAnchorX(float x);

	/**
	 * \if English
	 * Set anchor relative y position
	 *
	 * @param y relative y position
	 * \else
	 * 设置锚点的y位置
	 *
	 * @param y 相对y位置
	 * \endif
	 */
	virtual void setAnchorY(float y);
	
	/**
	 * 设置节点的大小
	 *
	 * @param w 节点象素宽度
	 * @param h 节点象素高度
	 */
	virtual void setContentSize(float w, float h);

	/**
	 * 设置节点位置
	 *
	 * @param x x位置
	 * @param y y位置
	 */
	virtual void setPosition(float x, float y);

	/**
	 * 平移节点
	 *
	 * @param x 平移的x值
	 * @param y 平移的y值
	 */
	virtual void translate(float x, float y);

	/**
	 * 设置旋转角度, 正值表示顺时针，负值表示逆时针
	 *
	 * @param rot 角度
	 */
	virtual void setRotation(float rot);

	/**
	 * 设置缩放比例
	 *
	 * @param scale 缩放比例, 将把x和y都设置成同样比例
	 */
	virtual void setScale(float scale);

	/**
	 * 设置x方向缩放比例
	 *
	 * @param scaleX x方向缩放比例
	 */
	virtual void setScaleX(float scaleX);

	/**
	 * 设置y方向缩放比例
	 *
	 * @param scaleY y方向缩放比例
	 */
	virtual void setScaleY(float scaleY);

	/**
	 * 设置节点的选择状态
	 *
	 * @param selected 选择状态
	 */
	virtual void setSelected(bool selected) { m_selected = selected; }

	/**
	 * 设置节点在OpenGL中的z order值
	 *
	 * @param vertexZ 在OpenGL中的z order值
	 */
	virtual void setVertexZ(float vertexZ) { m_vertexZ = vertexZ; }

	/**
	 * 设置节点是否可见. 这个状态如果为false，那么所有子节点的
	 * isVisibleFromRoot()也将返回false。一个visible状态为false的
	 * 节点无法接收到系统事件, 并且其子节点也无法接收到系统事件。
	 *
	 * @param visible true表示可见
	 */
	virtual void setVisible(bool visible) { m_visible = visible; }

	/**
	 * 设置节点是否获得焦点
	 *
	 * @param focused true获得焦点
	 */
	virtual void setFocused(bool focused);

	/**
	 * 设置节点的是否启用状态. 这个状态如果为false，那么所有子节点的
	 * isEnabledFromRoot()也将返回false。一个enable状态为false的
	 * 节点无法接收到系统事件, 并且其子节点也无法接收到系统事件。
	 *
	 * @param enabled 节点状态
	 */
	virtual void setEnabled(bool enabled) { m_enabled = enabled; }

	/////////////////////////////////
	// system event methods
	/////////////////////////////////

	/**
	 * 加速事件的回调. 这里的加速器值分成x, y, z三个维度, 它们的取值采用iOS的规则. Android和iOS
	 * 平台对加速器事件的参数主要有两个差异:
	 * 1. 它们的符号是完全相反的
	 * 2. iOS以1表示一个重力加速度, 而Android以9.81代表一个重力加速度
	 * 因此在Android平台上得到的值需要除以9.81并翻转符号.
	 *
	 * 之所以使用iOS规则表示加速器事件, 是因为其取值与OpenGL坐标系相符合.
	 *
	 * @param accelX x轴加速值
	 * @param accelY y轴加速值
	 * @param accelZ z轴加速值
	 */
	virtual void accelerometerChanged(float accelX, float accelY, float accelZ);

	/**
	 * Key Down事件的回调
	 *
	 * @param event key事件
	 */
	virtual bool keyDown(wyKeyEvent& event);

	/**
	 * Key Up事件的回调
	 *
	 * @param event key事件
	 */
	virtual bool keyUp(wyKeyEvent& event);

	/**
	 * Key Multiple事件的回调
	 *
	 * @param event key事件
	 */
	virtual bool keyMultiple(wyKeyEvent& event);
	
	/**
	 * Touches Began事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool touchesBegan(wyMotionEvent& e);

	/**
	 * Touches Moved事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool touchesMoved(wyMotionEvent& e);

	/**
	 * Touches Ended事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool touchesEnded(wyMotionEvent& e);

	/**
	 * Touches Cancelled事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool touchesCancelled(wyMotionEvent& e);

	/**
	 * Touches Pointer Began事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool touchesPointerBegan(wyMotionEvent& e);

	/**
	 * Touches Pointer Ended事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool touchesPointerEnded(wyMotionEvent& e);

	/**
	 * Double Tap事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool onDoubleTap(wyMotionEvent& e);

	/**
	 * Double Tap Event事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool onDoubleTapEvent(wyMotionEvent& e);

	/**
	 * Single Tap Confirmed事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool onSingleTapConfirmed(wyMotionEvent& e);

	/**
	 * Down事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool onDown(wyMotionEvent& e);

	/**
	 * Fling事件的回调
	 *
	 * @param e1 事件对象
	 * @param e2 事件对象
	 * @param velocityX Fling事件x轴速度
	 * @param velocityY Fling事件y轴速度
	 */
	virtual bool onFling(wyMotionEvent& e1, wyMotionEvent& e2, float velocityX, float velocityY);

	/**
	 * Long Press事件的回调
	 *
	 * @param event 屏幕触摸事件
	 */
	virtual void onLongPress(wyMotionEvent& event);

	/**
	 * Scroll事件的回调
	 *
	 * @param e1 事件对象
	 * @param e2 事件对象
	 * @param distanceX Scroll事件x轴距离
	 * @param distanceY Scroll事件y轴距离
	 */
	virtual bool onScroll(wyMotionEvent& e1, wyMotionEvent& e2, float distanceX, float distanceY);

	/**
	 * Show Press事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual void onShowPress(wyMotionEvent& e);

	/**
	 * Single Tap Up事件的回调
	 *
	 * @param e 屏幕触摸事件
	 */
	virtual bool onSingleTapUp(wyMotionEvent& e);

	/**
	 * 判断某个坐标是否落在了节点的矩形范围内，坐标必须是全局坐标
	 *
	 * @param x x坐标
	 * @param y y坐标
	 * @return true表示坐标在节点矩形范围内，false表示不在
	 */
	virtual bool hitTest(float x, float y);

	/**
	 * 设置是否position和anchor position分离
	 *
	 * @param flag true表示不分离，false表示分离
	 */
	virtual void setRelativeAnchorPoint(bool flag);

	/**
	 * 更新节点相对父节点的转换矩阵
	 */
	void updateNodeToParentTransform();

	/**
	 * 更新父节点相对节点的转换矩阵
	 */
	void updateParentToNodeTransform();

	/**
	 * 返回节点相对屏幕坐标轴的转换矩阵
	 *
	 * @return \link wyAffineTransform wyAffineTransform结构\endlink
	 */
	wyAffineTransform getNodeToWorldTransform();

	/**
	 * 返回当前节点相对父节点的转换矩阵
	 *
	 * @return \link wyAffineTransform wyAffineTransform结构\endlink
	 */	
	wyAffineTransform getTransformMatrix();

	/**
	 * 返回屏幕坐标轴相对节点的转换矩阵
	 *
	 * @return \link wyAffineTransform wyAffineTransform结构\endlink
	 */
	wyAffineTransform getWorldToNodeTransform();

	/**
	 * 设置变换矩阵状态为脏，这样Node会强制底层更新变换矩阵
	 */
	void setTransformDirty();

	/**
	 * 得到当前的缩放比例
	 *
	 * @return 缩放比例
	 */
	float getScale();

	/**
	 * 得到x轴缩放比例
	 *
	 * @return 缩放比例
	 */
	float getScaleX() { return m_scaleX; }

	/**
	 * 得到y轴缩放比例
	 *
	 * @return 缩放比例
	 */
	float getScaleY() { return m_scaleY; }

	/**
	 * 设置节点的网格对象
	 *
	 * @param grid 网格对象\link wyGridController wyGridController对象指针\endlink
	 */
	void setGrid(wyGridController* grid);

	/**
	 * 添加子节点,方法是线程安全的
	 *
	 * @param child 子节点\link wyNode wyNode对象指针\endlink
	 */
	virtual void addChildLocked(wyNode* child);

	/**
	 * 添加子节点,方法是线程安全的
	 *
	 * @param child 子节点\link wyNode wyNode对象指针\endlink
	 * @param z z轴顺序
	 */
	virtual void addChildLocked(wyNode* child, int z);

	/**
	 * 添加子节点,方法是线程安全的
	 *
	 * @param child 子节点\link wyNode wyNode对象指针\endlink
	 * @param z z轴顺序
	 * @param tag 子节点的标识
	 */
	virtual void addChildLocked(wyNode* child, int z, int tag);

	/**
	 * 添加子节点
	 *
	 * @param child 子节点\link wyNode wyNode对象指针\endlink
	 * @param z z轴顺序
	 * @param tag 子节点的标识
	 */
	virtual void addChild(wyNode* child, int z, int tag);

	/**
	 * 更新子节点的z轴顺序
	 *
	 * @param child 子节点\link wyNode wyNode对象指针\endlink
	 * @param z z轴顺序
	 */
	virtual int reorderChild(wyNode* child, int z);

	/**
	 * 删除所有子节点,方法是线程安全的
	 *
	 * @param cleanup true表示重置被删除的节点的状态。一个节点被clean之后将失去一些状态，比如附加在节点
	 * 		上的action，timer等，但是这个节点仍然可以用addChild加回来继续使用。
	 */
	virtual void removeAllChildrenLocked(bool cleanup);

	/**
	 * 删除所有子节点
	 *
	 * @param cleanup true表示重置被删除的节点的状态。一个节点被clean之后将失去一些状态，比如附加在节点
	 * 		上的action，timer等，但是这个节点仍然可以用addChild加回来继续使用。
	 */
	virtual void removeAllChildren(bool cleanup);

	/**
	 * 删除某个子节点,方法是线程安全的
	 *
	 * @param child 要删除的节点
	 * @param cleanup true表示重置被删除的节点的状态。一个节点被clean之后将失去一些状态，比如附加在节点
	 * 		上的action，timer等，但是这个节点仍然可以用addChild加回来继续使用。
	 */
	virtual void removeChildLocked(wyNode* child, bool cleanup);

	/**
	 * 根据tag删除某个子节点,方法是线程安全的
	 *
	 * @param tag 子节点的tag
	 * @param cleanup true表示重置被删除的节点的状态。一个节点被clean之后将失去一些状态，比如附加在节点
	 * 		上的action，timer等，但是这个节点仍然可以用addChild加回来继续使用。
	 */
	virtual void removeChildByTagLocked(int tag, bool cleanup);

	/**
	 * 删除某个子节点
	 *
	 * @param child 要删除的节点
	 * @param cleanup true表示重置被删除的节点的状态。一个节点被clean之后将失去一些状态，比如附加在节点
	 * 		上的action，timer等，但是这个节点仍然可以用addChild加回来继续使用。
	 */
	virtual void removeChild(wyNode* child, bool cleanup);

	/**
	 * 更新子节点的z轴顺序,方法是线程安全的
	 *
	 * @param child 子节点\link wyNode wyNode对象指针\endlink
	 * @param z z轴顺序
	 */
	virtual int reorderChildLocked(wyNode* child, int z);
	
	/**
	 * 把一个子节点挪动到最前面, 因此它会是最后渲染的子节点, 可能盖住其它的子节点
	 *
	 * @param child 子节点, 如果该节点不是当前节点的子节点, 则不做任何事
	 */
	virtual void bringToFront(wyNode* child);

	/**
	 * 把一个子节点挪动到最前面, 因此它会是最后渲染的子节点, 可能盖住其它的子节点. 该方法
	 * 是线程安全的
	 *
	 * @param child 子节点, 如果该节点不是当前节点的子节点, 则不做任何事
	 */
	virtual void bringToFrontLocked(wyNode* child);

	/**
	 * 把一个子节点挪到最后面, 因此它会是最先渲染的子节点, 后面的子节点可能覆盖它.
	 *
	 * @param child 子节点, 如果该节点不是当前节点的子节点, 则不做任何事
	 */
	virtual void bringToBack(wyNode* child);

	/**
	 * 把一个子节点挪到最后面, 因此它会是最先渲染的子节点, 后面的子节点可能覆盖它.
	 * 该方法是线程安全的
	 *
	 * @param child 子节点, 如果该节点不是当前节点的子节点, 则不做任何事
	 */
	virtual void bringToBackLocked(wyNode* child);

	/**
	 * 通过tag得到某个子节点,方法是线程安全的
	 *
	 * @param tag 子节点的tag
	 * @return 节点\link wyNode wyNode对象指针\endlink，如果没找到返回NULL
	 */
	virtual wyNode* getChildByTagLocked(int tag);

	/**
	 * 通过tag得到某个子节点
	 *
	 * @param tag 子节点的tag
	 * @return 节点\link wyNode wyNode对象指针\endlink，如果没找到返回NULL
	 */
	virtual wyNode* getChildByTag(int tag);

	/**
	 * 获得子节点队列中的第一个
	 *
	 * @return 节点\link wyNode wyNode对象指针\endlink，如果没有子节点返回NULL
	 */
	virtual wyNode* getFirstChild();

	/**
	 * 设置节点的速度. 方便于设置简单的物理功能, 对于只需要速度加速度的情况, 可以省掉
	 * 自己维护或者使用物理引擎的麻烦.
	 *
	 * @param vx x方向速度
	 * @param vy y方向速度
	 */
	virtual void setVelocity(float vx, float vy);

	/**
	 * 设置节点的加速度. 方便于设置简单的物理功能, 对于只需要速度加速度的情况, 可以省掉
	 * 自己维护或者使用物理引擎的麻烦.
	 *
	 * @param ax x方向加速度
	 * @param ay y方向加速度
	 */
	virtual void setAcceleration(float ax, float ay);

	/**
	 * 设置clip矩形, 这可以用来使节点的内容只在指定矩形范围内可见.
	 *
	 * @param clip clip矩形. 如果矩形的宽或高为0表示取消clip
	 * @param relativeToSelf true表示参数\c clip 代表的是一个相对于节点自身坐标的矩形, false表示
	 * 		参数\c clip 代表的是一个全局坐标矩形. 这是可选参数, 缺省情况下是false.
	 */
	virtual void setClipRect(wyRect clip, bool relativeToSelf = false);

	/**
	 * 得到clip矩形
	 *
	 * @return clip矩形. 如果矩形的宽或高为0表示没有clip
	 */
	wyRect getClipRect() { return m_clipRect; }

	/**
	 * 设置节点的加速度. 方便于设置简单的物理功能, 对于只需要速度加速度的情况, 可以省掉
	 * 自己维护或者使用物理引擎的麻烦.
	 *
	 * @param ax x方向加速度
	 */
	void setAccelerationX(float ax);

	/**
	 * 设置节点的加速度. 方便于设置简单的物理功能, 对于只需要速度加速度的情况, 可以省掉
	 * 自己维护或者使用物理引擎的麻烦.
	 *
	 * @param ay y方向加速度
	 */
	void setAccelerationY(float ay);

	/**
	 * 设置节点的x方向速度. 方便于设置简单的物理功能, 对于只需要速度加速度的情况, 可以省掉
	 * 自己维护或者使用物理引擎的麻烦.
	 *
	 * @param vx x方向速度
	 */
	void setVelocityX(float vx);

	/**
	 * 设置节点的y方向速度. 方便于设置简单的物理功能, 对于只需要速度加速度的情况, 可以省掉
	 * 自己维护或者使用物理引擎的麻烦.
	 *
	 * @param vy y方向速度
	 */
	void setVelocityY(float vy);

	/**
	 * 得到节点的全局坐标位置。返回的坐标根据relativeAnchorPoint标志的结果，如果是true则
	 * 表示是锚点，如果是false则表示是左下角
	 *
	 * @return 全局坐标位置
	 */
	wyPoint getAbsolutePosition();

	/**
	 * 在这个节点上运行一个动作
	 *
	 * @param action 动作\link wyAction wyAction对象指针\endlink
	 */
	void runAction(wyAction* action);

	/**
	 * 根据动作tag在这个节点上停止一个动作
	 *
	 * @param tag 动作tag
	 */
	void stopAction(int tag);

	/**
	 * 停止所有动作
	 *
	 * @param includeChildren true表示也停止子节点上的所有动作
	 */
	void stopAllActions(bool includeChildren = false);

	/**
	 * 暂停该节点上的所有动作, 之后可以通过resumeAllActions恢复
	 *
	 * @param includeChildren true表示也暂停子节点上的所有动作
	 */
	void pauseAllActions(bool includeChildren = false);

	/**
	 * 恢复该节点上的所有动作
	 *
	 * @param includeChildren true表示也恢复子节点上的所有动作
	 */
	void resumeAllActions(bool includeChildren = false);
	
	/**
	 * 暂停一个动作, 要暂停的动作通过tag指定. 如果不存在这个tag的动作, 则不做任何事.
	 * 动作暂停后可以用resumeAction或resumeAllActions恢复运行.
	 *
	 * \note
	 * 如果一个动作被其它的组合类动作所包含, 则暂停这样的动作是无效的
	 *
	 * @param tag 动作的tag
	 */
	void pauseAction(int tag);

	/**
	 * 恢复一个动作, 要恢复的动作通过tag指定. 如果不存在这个tag的动作, 则不做任何事.
	 *
	 * @param tag 动作的tag
	 */
	void resumeAction(int tag);
	
	/**
	 * 通过一个tag得到在这个节点上正在运行的\link wyAction wyAction\endlink 实例
	 *
	 * @param tag 动作的tag
	 * @return \link wyAction wyAction\endlink, 如果没有找到返回NULL
	 */
	wyAction* getAction(int tag);

	/**
	 * 检查是否这个节点上有一些动作正在运行
	 *
	 * @return true表示当前有至少一个动作在这个节点上运行
	 */
	bool hasRunningAction();

	// node to world/parent or vice versa, AR means relative to anchor point
	wyPoint worldToNodeSpace(wyPoint p);
	wyPoint worldToNodeSpaceAR(wyPoint p);
	wyPoint nodeToWorldSpace(wyPoint p);
	wyPoint nodeToWorldSpaceAR(wyPoint p);
	wyPoint parentToNodeSpace(wyPoint p);
	wyPoint parentToNodeSpaceAR(wyPoint p);
	wyPoint nodeToParentSpace(wyPoint p);
	wyPoint nodeToParentSpaceAR(wyPoint p);

	/**
	 * 返回节点自身坐标的矩形，(0，0)坐标到(width，height). 返回的矩形不会进行
	 * 变换, 不管节点是设置了缩放还是旋转, 返回的矩形始终是(0, 0)-(width, height).
	 * 返回矩形的origin代表左下角坐标
	 *
	 * @return \link wyRect wyRect结构\endlink
	 */
	wyRect getBoundingBox();

	/**
	 * 返回节点自身针对父节点坐标的矩形, 这个矩形经过了变换, 比如如果节点的原始
	 * 大小是(100, 100), 但是节点设置了放大2倍, 则得到的矩形大小是(200, 200).
	 * 但是如果节点还设置了旋转, 则返回的矩形是外接矩形, 其大小不一定反映节点的
	 * 真实宽高. 返回矩形的origin代表左下角坐标
	 *
	 * @return \link wyRect wyRect结构\endlink
	 */
	wyRect getBoundingBoxRelativeToParent();

	/**
	 * 返回节点自身针对整个坐标轴坐标的矩形, 这个矩形经过了变换, 比如如果节点的原始
	 * 大小是(100, 100), 但是节点设置了放大2倍, 则得到的矩形大小是(200, 200).
	 * 但是如果节点还设置了旋转, 则返回的矩形是外接矩形, 其大小不一定反映节点的
	 * 真实宽高. 返回矩形的origin代表左下角坐标
	 *
	 * @return \link wyRect wyRect结构\endlink
	 */
	wyRect getBoundingBoxRelativeToWorld();

	/**
	 * 设置是否启用接收加速器事件
	 *
	 * @param enabled true表示启用接收
	 */
	void setAccelerometerEnabled(bool enabled);

	/**
	 * 设置是否接收键盘事件
	 *
	 * @param enabled true表示启用接收
	 */
	void setKeyEnabled(bool enabled);

	/**
	 * 设置是否接收触摸事件
	 *
	 * @param enabled true表示启用接收
	 */
	void setTouchEnabled(bool enabled);

	/**
	 * 设置是否接收双击事件
	 *
	 * @param enabled true表示启用接收
	 */
	void setDoubleTapEnabled(bool enabled);

	/**
	 * 设置是否接收手势事件
	 *
	 * @param enabled true表示启用接收
	 */
	void setGestureEnabled(bool enabled);

	/**
	 * 获得当前是否接收触摸事件
	 *
	 * @return true表示启用接收
	 */
	bool isTouchEnabled() { return m_touchEnabled; }

	/**
	 * 获得当前是否接收键盘事件
	 *
	 * @return true表示启用接收
	 */
	bool isKeyEnabled() { return m_keyEnabled; }

	/**
	 * 获得当前是否接收加速事件
	 *
	 * @return true表示启用接收
	 */
	bool isAccelerometerEnabled() { return m_accelerometerEnabled; }

	/**
	 * 获得当前是否接收手势事件
	 *
	 * @return true表示启用接收
	 */
	bool isGestureEnabled() { return m_gestureEnabled; }

	/**
	 * 获得当前是否接收双击事件
	 *
	 * @return true表示启用接收
	 */
	bool isDoubleTabEnabled() { return m_doubleTabEnabled; }

	/**
	 * \if English
	 * Get anchor position relative to self coordinates
	 *
	 * @return x position
	 * \else
	 * 得到锚点相对于节点自身坐标系的x坐标
	 *
	 * @return x位置
	 * \endif
	 */
	float getAnchorPointX() { return m_anchorPointX; }

	/**
	 * \if English
	 * Get anchor position relative to self coordinates
	 *
	 * @return y position
	 * \else
	 * 得到锚点相对于节点自身坐标系的y坐标
	 *
	 * @return y位置
	 * \endif
	 */
	float getAnchorY() { return m_anchorPointY; }

	/**
	 * \if English
	 * Get anchor x relative position
	 *
	 * @return x relative position
	 * \else
	 * 得到锚点的x方向比例
	 *
	 * @return 锚点x比例，从0到1
	 * \endif
	 */
	float getAnchorX() { return m_anchorX; }

	/**
	 * \if English
	 * Get anchor relative y position
	 *
	 * @return y relative position
	 * \else
	 * 得到锚点的y方向比例
	 *
	 * @return 锚点y比例，从0到1
	 * \endif
	 */
	float getAnchorY() { return m_anchorY; }

	/**
	 * 得到节点上关联的相机对象
	 *
	 * @return 相机\link wyCamera wyCamera对象指针\endlink
	 */
	wyCamera* getCamera();

	/**
	 * 检查节点上是否有相机. 相机是一个\link wyCamera wyCamera\endlink对象,
	 * 只在需要的时候才会创建, 因此有可能为NULL.
	 *
	 * @return true表示当前有一个相机关联到节点
	 */
	bool hasCamera() { return m_camera != NULL; }

	/**
	 * 得到节点上绑定的网格对象
	 *
	 * @return 网格\link wyGridController wyGridController对象指针\endlink
	 */
	wyGridController* getGrid() { return m_grid; }

	/**
	 * 得到节点是否可见
	 *
	 * @return true表示节点可见
	 */
	bool isVisible() { return m_visible; }

	/**
	 * 得到节点是否获得焦点
	 *
	 * @return true表示节点获得焦点
	 */
	bool isFocused() { return m_focused; }

	/**
	 * 得到节点的真正可见状态，它会检查是否节点的某个祖先节点是不可见的
	 *
	 * @return true表示节点可见，false表示表示在节点树上有一个节点不可见，因此导致它也不可见
	 */
	bool isVisibleFromRoot();

	/**
	 * 得到节点的选择状态
	 *
	 * @return 节点的选择状态，true标识被选中
	 */
	bool isSelected() { return m_selected; }

	/**
	 * 得到节点的可用状态
	 *
	 * @return 节点的可用状态，true标识可用
	 */
	bool isEnabled() { return m_enabled; }

	/**
	 * 得到节点的可用状态, 它会检查是否节点的某个祖先节点是不是可用的
	 *
	 * @return 节点的可用状态，true标识可用
	 */
	bool isEnabledFromRoot();

	/**
	 * 得到节点在整个OpenGL中的z order值
	 *
	 * @return 节点在整个OpenGL中的z order值
	 */
	int getVertexZ() { return m_vertexZ; }

	/**
	 * 获取旋转角度，正值表示顺时针，负值表示逆时针
	 *
	 * @return 旋转角度
	 */
	float getRotation() { return m_rotation; }

	/**
	 * 得到当前位置的x值
	 *
	 * @return 当前位置的x值
	 */
	float getPositionX() { return m_positionX; }

	/**
	 * 得到当前位置的y值
	 *
	 * @return 当前位置的y值
	 */
	float getPositionY() { return m_positionY; }
	
	/**
	 * 获得原点的x坐标, 原点即左下角的x坐标, 根据节点设置的不同, 左下角坐标
	 * 可能等于position也可能不等于
	 *
	 * @return 左下角的x坐标
	 */
	float getOriginX();

	/**
	 * 获得原点的y坐标, 原点即左下角的x坐标, 根据节点设置的不同, 左下角坐标
	 * 可能等于position也可能不等于
	 *
	 * @return 左下角的y坐标
	 */
	float getOriginY();

	/**
	 * 得到是否position和anchor position是分离的
	 *
	 * @return true表示不分离，false表示分离
	 */
	bool isRelativeAnchorPoint() { return m_relativeAnchorPoint; }

	/**
	 * 得到节点当前是否在运行中
	 *
	 * @return true表示节点当前在一个正在运行的场景中
	 */
	bool isRunning() { return m_running; }

	/**
	 * 得到节点的宽度
	 *
	 * @return 节点象素宽度
	 */
	float getWidth() { return m_width; }

	/**
	 * 得到节点高度
	 *
	 * @return 节点象素高度
	 */
	float getHeight() { return m_height; }

	/**
	 * 得到节点的x方向速度
	 *
	 * @return x方向速度, 单位是像素
	 */
	float getVelocityX() { return m_velocityX; }

	/**
	 * 得到节点的y方向速度
	 *
	 * @return y方向速度, 单位是像素
	 */
	float getVelocityY() { return m_velocityY; }

	/**
	 * 得到节点的速度
	 *
	 * @return 节点的速度, 单位是像素
	 */
	wyPoint getVelocity() { return wyp(m_velocityX, m_velocityY); }

	/**
	 * 得到节点的x方向加速度
	 *
	 * @return x方向加速度, 单位是像素
	 */
	float getAccelerationX() { return m_accelerationX; }

	/**
	 * 得到节点的y方向加速度
	 *
	 * @return y方向加速度, 单位是像素
	 */
	float getAccelerationY() { return m_accelerationY; }

	/**
	 * 得到节点的加速度
	 *
	 * @return 节点的加速度, 单位是像素
	 */
	wyPoint getAcceleration() { return wyp(m_accelerationX, m_accelerationY); }

	/**
	 * 得到节点尺寸\link wySize wySize结构\endlink
	 *
	 * @return 节点尺寸\link wySize wySize结构\endlink
	 */
	wySize getContentSize() { return wys(m_width, m_height); }

	/**
	 * 得到子节点\link wyArray wyArray对象指针\endlink
	 *
	 * @return 子节点\link wyArray wyArray对象指针\endlink
	 */
	wyArray* getChildren() { return m_children; }
	
	/**
	 * \if English
	 * Get child node at specified index
	 *
	 * @param index index of child
	 * @return \link wyNode wyNode\endlink, or NULL if \c index is invalid
	 * \else
	 * 得到指定位置处的子节点
	 *
	 * @param index 子节点索引
	 * @return \link wyNode wyNode\endlink, 如果\c index不合法则返回NULL
	 * \endif
	 */
	wyNode* getChildAt(int index) { return (wyNode*)wyArrayGet(m_children, index); }

	/**
	 * 得到子节点数量
	 *
	 * @return 子节点数量
	 */
	int getChildCount() { return m_children->num; }

	/**
	 * 得到父节点\link wyNode wyNode对象指针\endlink
	 *
	 * @return 父节点\link wyNode wyNode对象指针\endlink
	 */
	wyNode* getParent() { return m_parent; }

	/**
	 * 设置父节点\link wyNode wyNode对象指针\endlink
	 *
	 * @param p 父节点\link wyNode wyNode对象指针\endlink
	 */
	void setParent(wyNode* p) { m_parent = p; }

	/**
	 * 设置节点标识
	 *
	 * @param tag 节点标识
	 */
	void setTag(int tag) { m_tag = tag; }

	/**
	 * 得到节点标识
	 *
	 * @return 节点标识
	 */
	int getTag() { return m_tag; }

	/**
	 * 设置节点在OpenGL中的z轴顺序值
	 *
	 * @param z 节点在OpenGL中的z轴顺序值
	 */
	void setZOrder(int z) { m_zOrder = z; }

	/**
	 * 得到节点在OpenGL中的z轴顺序值
	 *
	 * @return 节点在OpenGL中的z轴顺序值
	 */
	int getZOrder() { return m_zOrder; }

	/**
	 * 添加一个定时器\link wyTimer wyTimer对象指针\endlink
	 *
	 * @param t 定时器\link wyTimer wyTimer对象指针\endlink
	 */
	void scheduleLocked(wyTimer* t);

	/**
	 * 删除一个定时器\link wyTimer wyTimer对象指针\endlink
	 *
	 * @param t 定时器\link wyTimer wyTimer对象指针\endlink
	 */
	void unscheduleLocked(wyTimer* t);

	/**
	 * 得到是否绘制节点的标志
	 *
	 * @return true表示不绘制节点，false表示绘制节点
	 */
	bool isNoDraw() { return m_noDraw; }

	/**
	 * 设置是否绘制节点的标志
	 *
	 * @param flag true表示不绘制节点，false表示绘制节点
	 */
	void setNoDraw(bool flag) { m_noDraw = flag; }

	
	/**
	 * 设置节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 *
	 * @param ts 节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	void setDownSelector(wyTargetSelector* ts);

	/**
	 * 得到节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 *
	 * @return 节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	wyTargetSelector* getDownSelector() { return m_downSelector; }

	/**
	 * 设置节点松开\link wyTargetSelector wyTargetSelector对象指针\endlink
	 *
	 * @param ts 节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	void setUpSelector(wyTargetSelector* ts);

	/**
	 * 得到节点松开\link wyTargetSelector wyTargetSelector对象指针\endlink
	 *
	 * @return 节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	wyTargetSelector* getUpSelector() { return m_upSelector; }

	/**
	 * 设置节点按下后移出\link wyTargetSelector wyTargetSelector对象指针\endlink
	 *
	 * @param ts 节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	void setMoveOutSelector(wyTargetSelector* ts);

	/**
	 * 得到节点按下后移出\link wyTargetSelector wyTargetSelector对象指针\endlink
	 *
	 * @return 节点按下\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	wyTargetSelector* getMoveOutSelector() { return m_moveOutSelector; }

	/* other optional interface, we don't use multiple inheritance */

	/* IFrames */
	/**
	 * 添加一个动画
	 *
	 * @param animation \link wyAnimation wyAnimation对象指针\endlink
	 */
	virtual void addAnimation(wyAnimation* animation) {}

	/**
	 * 通过id获得动画对象
	 *
	 * @param id 动画id
	 * @return \link wyAnimation wyAnimation对象指针\endlink
	 */
	virtual wyAnimation* getAnimationById(int id) { return NULL; }

	/**
	 * 获得当前帧
	 *
	 * @return \link wyFrame wyFrame对象指针\endlink, 如果当前没有帧被设置，则可以返回NULL
	 */
	virtual wyFrame* getDisplayFrame() { return NULL; }

	/**
	 * 检查某帧是否现在正在显示
	 *
	 * @param frame \link wyFrame wyFrame对象指针\endlink
	 * @return true为是
	 */
	virtual bool isFrameDisplayed(wyFrame* frame) { return false; }

	/**
	 * 设置当前帧
	 *
	 * @param newFrame \link wyFrame wyFrame对象指针\endlink
	 */
	virtual void setDisplayFrame(wyFrame* newFrame) {}

	/**
	 * 通过动画id和帧索引设置当前帧
	 *
	 * @param id 动画id
	 * @param frameIndex 帧索引
	 */
	virtual void setDisplayFrameById(int id, int frameIndex) {}

	/* ILabel */

	/**
	 * 获得文字内容, 字符串以NULL结尾
	 *
	 * @return 返回的字符串，编码为utf-8
	 */
	virtual const char* getText() { return NULL; }

	/**
	 * 设置文字内容. 如果一个节点支持设置文字内容，则应该实现这个方法
	 *
	 * @param text 要显示的字符串，NULL结尾，编码为utf-8, 可以通过wyUtils::getString获得字符串资源
	 */
	virtual void setText(const char* text) {}

	/* ITransparent */

	/**
	 * 得到当前alpha值
	 *
	 * @return alpha值
	 */
	virtual int getAlpha() { return 255; }

	/**
	 * 设置alpha值
	 *
	 * @param alpha alpha值
	 */
	virtual void setAlpha(int alpha) {}

	/* IRGB */

	/**
	 * 得到当前颜色
	 *
	 * @return 颜色\link wyColor3B wyColor3B结构\endlink
	 */
	virtual wyColor3B getColor() { return wyc3bWhite; }

	/**
	 * 设置颜色
	 *
	 * @param color \link wyColor3B wyColor3B结构\endlink
	 */
	virtual void setColor(wyColor3B color) {}

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color) {}

	/* ITextureOwner */

	/**
	 * 得到当前\link wyTexture2D wyTexture2D对象指针\endlink
	 *
	 * @return \link wyTexture2D wyTexture2D对象指针\endlink
	 */
	virtual wyTexture2D* getTexture() { return NULL; }

	/**
	 * 设置\link wyTexture2D wyTexture2D对象指针\endlink
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 */
	virtual void setTexture(wyTexture2D* tex) {}

	/**
	 * 把当前节点的大小调整为能完整包含所有子节点，如果当前节点有一个子节点，它
	 * 相对于当前节点的坐标是(10, 10), 大小是(100, 100), 那么实际上要把当前
	 * 节点的大小改成(110, 110). 如果子节点在该方法调用时还具有旋转或缩放的属性，
	 * 则实际计算的是子节点的外接矩形。
	 */
	void sizeToFit();

	/**
	 * 将节点扩大, 扩大的尺寸通过四个方向的距离指定. 这个方法配合sizeToFit使用, 可以较方便的
	 * 控制父节点的大小.
	 *
	 * @param left 左边扩大的大小
	 * @param top 上边扩大的大小
	 * @param right 右边扩大的大小
	 * @param bottom 下边扩大的大小
	 */
	void enlargeNode(float left, float top, float right, float bottom);

	/**
	 * 在lazy release pool中查找某个对象, 如果找到了, 则从lazy release
	 * pool中删除并减少引用计数. 这个方法主要的目的是方便java层能够释放native层
	 * 对象, 开发者在任何时候都不应该调用此方法.
	 */
	void javaRelease(bool includeChildren);

	/**
	 * 设置触摸事件优先级
	 *
	 * @param p 优先级数值, 越大则越先收到事件
	 */
	void setTouchPriority(int p) { m_touchPriority = p; }

	/**
	 * 设置按键事件优先级
	 *
	 * @param p 优先级数值, 越大则越先收到事件
	 */
	void setKeyPriority(int p) { m_keyPriority = p; }

	/**
	 * 设置手势事件优先级
	 *
	 * @param p 优先级数值, 越大则越先收到事件
	 */
	void setGesturePriority(int p) { m_gesturePriority = p; }

	/**
	 * 设置双击事件优先级
	 *
	 * @param p 优先级数值, 越大则越先收到事件
	 */
	void setDoubleTapPriority(int p) { m_doubleTapPriority = p; }

	/**
	 * 设置加速器事件优先级
	 *
	 * @param p 优先级数值, 越大则越先收到事件
	 */
	void setAccelerometerPriority(int p) { m_accelerometerPriority = p; }

	/**
	 * 获得触摸事件优先级
	 *
	 * @return p 优先级数值, 越大则越先收到事件
	 */
	int getTouchPriority() { return m_touchPriority; }

	/**
	 * 获得按键事件优先级
	 *
	 * @return p 优先级数值, 越大则越先收到事件
	 */
	int getKeyPriority() { return m_keyPriority; }

	/**
	 * 获得手势事件优先级
	 *
	 * @return p 优先级数值, 越大则越先收到事件
	 */
	int getGesturePriority() { return m_gesturePriority; }

	/**
	 * 获得双击事件优先级
	 *
	 * @return p 优先级数值, 越大则越先收到事件
	 */
	int getDoubleTapPriority() { return m_doubleTapPriority; }

	/**
	 * 获得加速器事件优先级
	 *
	 * @return p 优先级数值, 越大则越先收到事件
	 */
	int getAccelerometerPriority() { return m_accelerometerPriority; }

	/**
	 * 设置位置事件回调接口
	 *
	 * @param listener \link wyNodePositionListener wyNodePositionListener\endlink
	 * @param data 附加数据指针
	 */
	void setPositionListener(wyNodePositionListener* listener, void* data);
	
	/**
	 * 判断当前节点是否是某个节点的父节点或更高的节点
	 *
	 * @param node 要检查的节点, 如果该节点是当前节点的子孙, 则返回true
	 * @param 如果\c node 是当前节点的子孙, 则返回true
	 */
	bool isAncestor(wyNode* node);
	
	/**
	 * 设置节点是否在非第一触点的情况下也触发点击事件
	 *
	 * @param flag true表示在非第一触点的情况下也触发点击事件
	 */
	void setMultiTouchClickable(bool flag) { m_multiTouchClickable = flag; }

	/**
	 * 节点是否在非第一触点的情况下也触发点击事件
	 *
	 * @return true表示在非第一触点的情况下也触发点击事件
	 */
	bool isMultiTouchClickable() { return m_multiTouchClickable; }
};

#endif // __wyNode_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyParallaxNode_h__


/**
 * @class wyParallaxNode
 *
 * 视差滚动支持。可以为子节点指定视差比率，视差比率越大的子节点移动越迅速，所以会产生一种
 * 远近程度不同的感觉。 视差节点创建后，需要调用sizeToFit方法进行视差节点
 * 和子节点的大小调整。如果不手动设置， 视差节点的大小会自动设置成最大的子节点大小。子节点位置是相对于
 * 视差节点的锚点来决定的。如果最终视差节点的大小是100x100, 锚点在(0.5, 0.5), 某个子节点的
 * x,y偏移值是(10, 20), 则子节点的position是(60, 70)
 */
class wyParallaxNode : public wyNode {
public:
	static wyParallaxNode* make();

	wyParallaxNode();
	virtual ~wyParallaxNode();
	
	/// @see wyNode::addChild
	virtual void addChild(wyNode* child, int z, int tag);

	/// @see wyNode::removeAllChildren
	virtual void removeAllChildren(bool cleanup);

	/// @see wyNode::removeChild
	virtual void removeChild(wyNode* child, bool cleanup);

	/**
	 * 对视差节点进行内部位移, 这个方法不改变视差节点的位置, 只是改变视差字节内子节点的位置
	 *
	 * @param dx x位移
	 * @param dy y位移
	 */
	void offsetBy(float dx, float dy);
	
	/**
	 * 添加子节点
	 *
	 * @param child 子节点
	 * @param z 子节点的z order值
	 * @param ratioX x视差比例
	 * @param ratioY y视差比例
	 */
	void addChild(wyNode* child, int z, float ratioX, float ratioY);
	
	/**
	 * 开始fling, 如果当前正在fling，则不做任何事.
	 *
	 * @param velocityX x方向的fling速度, 如果没有设置水平平铺，则被忽略
	 * @param velocityY y方向的fling速度, 如果没有设置垂直平铺，则被忽略
	 */
	void fling(float velocityX, float velocityY);

	/**
	 * 中止fling，如果当前没有在fling，则不做任何事
	 */
	void stopFling();

	int getOffsetX() { return m_xOffset; }

	int getOffsetY() { return m_yOffset; }

	void setMinX(int x);

	void setMinY(int y);

	float getMinX() { return m_minXOffset; }

	float getMinY() { return m_minYOffset; }

	void setMaxX(int x);

	void setMaxY(int y);

	int getMaxX() { return m_maxXOffset; }

	int getMaxY() { return m_maxYOffset; }
};

#endif // __wyParallaxNode_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyProgressTimer_h__


/**
 * @class wyProgressTimer
 *
 * 进度条节点对象，可以包装任意图片对象，实现只显示百分之0到100的效果。
 * 进度条的样式可以为条型或者扇形
 */
class wyProgressTimer : public wyNode {
public:
	/**
	 * 通过一个\link wyTexture2D wyTexture2D\endlink 对象构造一个
	 * 进度条，通过这种方式构造的进度条将使用这个贴图的完整大小.
	 *
	 * @param tex 贴图\link wyTexture2D wyTexture2D对象指针\endlink
	 */
	static wyProgressTimer* make(wyTexture2D* tex);

	/**
	 * 通过一个\link wySprite wySprite\endlink 构造一个进度条.
	 * 进度条可能只使用相关贴图的一部分，因为sprite也许是个图片集贴图。
	 *
	 * @param sprite \link wySprite wySprite\endlink 指针
	 */
	static wyProgressTimer* make(wySprite* sprite);

	/**
	 * 析构函数
	 */
	virtual ~wyProgressTimer();

	/**
	 * 设置进度，从0到100
	 *
	 * @param percentage 进度
	 */
	void setPercentage(float percentage);

	/**
	 * 得到进度，从0到100
	 *
	 * @return 进度
	 */
	float getPercentage() { return m_percentage; }

	/**
	 * 增加指定值, 如果超过100, 则当前值改为100
	 *
	 * @param delta 要变化的值
	 */
	void increase(float delta);

	/**
	 * 设置图片
	 *
	 * @param sprite \link wySprite wySprite对象指针\endlink
	 */
	void setSprite(wySprite* sprite);

	/**
	 * 设置进度样式
	 *
	 * @param style 样式
	 */
	void setStyle(wyProgress::Style style);
};

#endif // __wyProgressTimer_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyRenderTexture_h__


/**
 * @class wyRenderTexture
 *
 * 设置自定义frame buffer，使渲染结果保存在贴图中。用于实现一些特殊效果
 */
class wyRenderTexture : public wyNode  {
public:
	/**
	 * 静态构造函数
	 *
	 * @param width 宽度
	 * @param height 高度
	 */
	static wyRenderTexture* make(int width, int height);
	
	/**
	 * \if English
	 * Create a render texture which is full screen size
	 * \else
	 * 创建一个全屏大小的渲染贴图
	 * \endif
	 */
	static wyRenderTexture* make();

	/**
	 * 析构函数
	 */
	virtual ~wyRenderTexture();

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_color.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha) { m_color.a = alpha; }

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);
	
	/**
	 * Render之前调用的方法
	 */
	void beginRender();

	/**
	 * Render之后调用的方法
	 */
	void endRender();
};

#endif // __wyRenderTexture_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyRibbon_h__


/**
 * @class wyRibbon
 *
 * Ribbon是一个动态多边形列表，在渲染时通过一系列三角形绘制出来，形成一个带状的效果。Ribbon
 * 主要的用途是和\link wyMotionStreak wyMotionStreak\endlink结合使用用来显示动作轨迹。
 * 如果想要直接只用Ribbon, 可以调用addPointAt添加新端点，Ribbon会根据新的端点和上一次端点生成新多边形。
 * Ribbon的数据存放在wyRibbonSegment类中，这个类会根据当前顶点数分配空间，
 * 如果顶点数超过一定数量，Ribbon会创建新的wyRibbonSegment，这是为了避免过于频繁的分配内存。
 */
class wyRibbon : public wyNode {
public:
    /**
	 * 析构函数
	 */
    virtual ~wyRibbon();

	/// @see wyNode::setContentSize
	virtual void setContentSize(float w, float h);

	/**
	 * 强制指定下一个新端点会产生一个新的RibbonSegment
	 */
	virtual void forceFirstPoint() { m_firstPoint = true; }

	/**
	 * 被Scheduler调用的方法，不要手动调用
	 *
	 * @param delta 帧刷新的间隔时间
	 */
	virtual void update(float delta) = 0;

	/**
	 * 添加一个新端点
	 *
	 * @param location 顶点\link wyPoint wyPoint对象指针\endlink
	 */
	virtual void addPoint(wyPoint location) = 0;

	/**
	 * 重置ribbon，清除当前的点，擦除所有绘制内容
	 */
	virtual void reset() = 0;
};

#endif // __wyRibbon_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyScene_h__


/**
 * @class wyScene
 *
 * 场景对象的封装
 */
class wyScene : public wyNode {
public:
	static wyScene* make();
	
	/**
	 * 构造函数
	 */
	wyScene();

	/**
	 * 析构函数
	 */
	virtual ~wyScene();

	/// @see wyNode::keyDown
	virtual bool keyDown(wyKeyEvent& event);

	/// @see wyNode::keyUp
	virtual bool keyUp(wyKeyEvent& event);

	/**
	 * 检查这是否是一个transition scene, 这个方法只是为了避免使用RTTI而添加的一个方法
	 *
	 * @return true表示这是一个transition scene, 一般情况下也就意味着这是一个\link wyTransitionScene wyTransitionScene\endlink 的子类
	 */
	virtual bool isTransition() { return false; }
};

#endif // __wyScene_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyScheduler_h__



// equal function
bool wyTimerEquals(void* ptr1, void* ptr2, void* data);


class wyScheduler;

/**
 * @class wyTimer
 *
 *  定时器的封装
 */
class wyTimer : public wyObject {

public:
	/**
	 * 静态构造函数
	 *
	 * @param ts 定时器回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	static wyTimer* make(wyTargetSelector* ts);

	/**
	 * 静态构造函数
	 *
	 * @param ts 定时器回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param interval 间隔时间, 如果值为0且m_frame也是0，表示尽可能快的调用，相当于每帧都调用
	 */
	static wyTimer* make(wyTargetSelector* ts, float interval);

	/**
	 * 静态构造函数
	 *
	 * @param ts 定时器回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param frame 帧刷新，如果是0，表示通过时间调用. 如果m_interval也是0，表示尽可能快的调用，也就是相当于每帧都调用
	 */
	static wyTimer* make(wyTargetSelector* ts, int frame);

	/**
	 * 构造函数
	 *
	 * @param ts 定时器回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	wyTimer(wyTargetSelector* ts);

	/**
	 * 构造函数
	 *
	 * @param ts 定时器回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param interval 间隔时间, 如果值为0且m_frame也是0，表示尽可能快的调用，相当于每帧都调用
	 */
	wyTimer(wyTargetSelector* ts, float interval);

	/**
	 * 构造函数
	 *
	 * @param ts 定时器回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 * @param frame 帧刷新，如果是0，表示通过时间调用. 如果m_interval也是0，表示尽可能快的调用，也就是相当于每帧都调用
	 */
	wyTimer(wyTargetSelector* ts, int frame);

	/**
	 * 析构函数
	 */
	virtual ~wyTimer();

	/**
	 * 设置间隔时间,如果当前是按帧刷新，设置一个大于0的间隔时间，将改变当前定时器为按时间刷新
	 *
	 * @param interval 间隔时间, 如果值为0且m_frame也是0，表示尽可能快的调用，相当于每帧都调用
	 */
	void setInterval(float interval);

	/**
	 * 获得间隔时间,如果是0标识用帧调用
	 *
	 * @return 间隔时间, 如果值为0且m_frame也是0，表示尽可能快的调用，相当于每帧都调用
	 */
	float getInterval() { return m_interval; }

	/**
	 * 设置帧刷新的帧数控制
	 *
	 * @param frame 帧刷新，如果是0，表示通过时间调用. 如果m_interval也是0，表示尽可能快的调用，也就是相当于每帧都调用
	 */
	void setFrame(int frame) { m_frame = frame; }

	/**
	 * 获得帧刷新数字，如果是0，标识时间调用
	 *
	 * @return 帧刷新数字，如果是0，表示通过时间调用. 如果m_interval也是0，表示尽可能快的调用，也就是相当于每帧都调用
	 */
	int getFrame() { return m_frame; }

	/**
	 * 触发定时器，如果符合条件则调用
	 *
	 * @param delta 帧与帧之间的间隔时间
	 */
	void fire(float delta);

	/**
	 * 设置此定时器是否只调用一次
	 *
	 * @param flag true为只用一次
	 */
	void setOneShot(bool flag) { m_oneShot = flag; }

	/**
	 * 返回此定时器是否只调用一次
	 *
	 * @return true为只用一次
	 */
	bool isOneShot() { return m_oneShot; }

	/**
	 * \if English
	 * Set max invocation count of this timer. If you set to 1, then
	 * it is same as \c setOneShot(true). Zero means no limitation
	 * \else
	 * 设置这个定时器最大的触发次数, 设置成1和\c setOneShot(true)的作用是相同的.
	 * 0表示不限制触发次数
	 * \endif
	 */
	void setMaxInvocation(int max) { m_maxInvocation = max; }

	/**
	 * \if English
	 * Get max invocation count of this timer. For a one shot timer, it returns 1.
	 * Zero means no limitation
	 * \else
	 * 得到定时器的最大触发次数, 对于one shot是true的定时器, 返回1. 0表示没有限制
	 * \endif
	 */
	int getMaxInvocation() { return m_maxInvocation; }

	/**
	 * \if English
	 * Get current invocation count
	 * \else
	 * 得到当前已经触发的次数
	 * \endif
	 */
	int getCurrentInvocationCount() { return m_counter; }
	
	/**
	 * 返回已经持续执行的时间，直到上次运行为止
	 *
	 * @return 已经持续执行的时间，直到上次运行为止
	 */
	float getElapsed() { return m_elapsed; }

	/**
	 * 获得定时回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 *
	 * @return 定时回调\link wyTargetSelector wyTargetSelector对象指针\endlink
	 */
	wyTargetSelector* getTargetSelector() { return m_targetSelector; }
};

/**
 * @class wyScheduler
 *
 *  调度器的封装
 */
class wyScheduler : public wyObject {

public:
	/**
	 * 获得\link wyScheduler wyScheduler对象指针\endlink
	 *
	 * @return \link wyScheduler wyScheduler对象指针\endlink
	 */
	static wyScheduler* getInstance();

	/**
	 * 析构函数
	 */
	virtual ~wyScheduler();

	/**
	 * 添加定时器到调度管理，此方法是线程安全的
	 *
	 * @param t 定时器的\link wyTimer wyTimer对象指针\endlink
	 */
	void scheduleLocked(wyTimer* t);

	/**
	 * 删除定时器从调度管理，此方法是线程安全的
	 *
	 * @param t 定时器的\link wyTimer wyTimer对象指针\endlink
	 */
	void unscheduleLocked(wyTimer* t);

	/**
	 * 设置快慢动作的执行，大于1为快动作，小于1为慢动作
	 *
	 * @param scale 快慢动作的执行，大于1为快动作，小于1为慢动作
	 */
	void setTimeScale(float scale) { m_timeScale = scale; }

	/**
	 * 获得快慢动作的执行，大于1为快动作，小于1为慢动作
	 *
	 * @return 快慢动作的执行，大于1为快动作，小于1为慢动作
	 */
	float getTimeScale() { return m_timeScale; }
};

#endif //__wyScheduler_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wySprite_h__


/**
 * @class wySprite
 *
 * 图片对象的封装
 */
class wySprite : public wyTextureNode {
public:
	/**
	 * 构造\link wySprite wySprite对象指针\endlink
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 * @return \link wySprite wySprite对象指针\endlink
	 */
	static wySprite* make(wyTexture2D* tex);

	/**
	 * 构造\link wySprite wySprite对象指针\endlink
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 * @param texRect 贴图区域，单位为像素
	 * @return \link wySprite wySprite对象指针\endlink
	 */
	static wySprite* make(wyTexture2D* tex, wyRect texRect);

	/**
	 * 根据\link wyZwoptexFrame wyZwoptexFrame\endlink 构造一个sprite对象
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 * @param f \link wyZwoptexFrame wyZwoptexFrame\endlink 对象
	 * @return \link wySprite wySprite对象指针\endlink
	 */
	static wySprite* make(wyTexture2D* tex, wyZwoptexFrame* f);

	/**
	 * 构造函数
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 */
	wySprite(wyTexture2D* tex);

	/**
	 * 构造函数
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 * @param texRect 贴图区域，单位为像素
	 */
	wySprite(wyTexture2D* tex, wyRect texRect);

	/**
	 * 根据\link wyZwoptexFrame wyZwoptexFrame\endlink 构造一个sprite对象
	 *
	 * @param tex \link wyTexture2D wyTexture2D对象指针\endlink
	 * @param f \link wyZwoptexFrame wyZwoptexFrame\endlink 对象
	 */
	wySprite(wyTexture2D* tex, wyZwoptexFrame* f);

	/**
	 * 析构函数
	 */
	virtual ~wySprite();
};

#endif // __wySprite_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wySpirteBatchNode_h__


class wySpriteEx;
class wyMWSprite;

/**
 * @class wySpriteBatchNode
 *
 * 用于图像节点的批处理，仅接受 \link wySpriteEx wySpriteEx \endlink 作为子节点。
 * 所有子节点共享一张贴图，所有节点的绘制一次完成，可提高性能。
 */
class wySpriteBatchNode : public wyNode {

public:
	/**
	 * 创建一个wySpriteBatchNode类型的节点
	 *
	 * @param[in] tex 贴图
	 */
	static wySpriteBatchNode* make(wyTexture2D* tex);

	/**
	 * 构造函数
	 *
	 * @param[in] tex 贴图
	 */
	wySpriteBatchNode(wyTexture2D* tex);
	
	///析构函数
	virtual ~wySpriteBatchNode();

	/**
	 * \if English
	 * Set marker position, it will affect \c drawFromMarker method
	 *
	 * @param mark position of marker
	 * \else
	 * 设置标记位置, 将会影响\c drawFromMarker方法
	 *
	 * @param mark 标记位置
	 * \endif
	 */
	void setMarker(int pos) { m_marker = pos; }

	/**
	 * \if English
	 * Get current marker position
	 *
	 * @return current marker position
	 * \else
	 * 得到当前的标记位置
	 *
	 * @return 当前标记位置
	 * \endif
	 */
	int getMarker() { return m_marker; }
};

#endif
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wySpriteEx_h__


/**
 * @class wySpriteEx
 *
 * 图像节点，有两种模式，批渲染模式和单独渲染模式。
 * 要启用批渲染模式，需要将节点作为子节点插入一个 \link wySpriteBatchNode wySpriteBatchNode \endlink 节点.
 * 在批渲染模式下，所使用的贴图为父wySpriteBatchNode贴图。
 */
class wySpriteEx : public wyTextureNode
{

public:
	/**
	 * 创建一个图像节点，所用贴图区域为整个贴图
	 *
	 * @param[in] pTex 贴图
	 */
	static wySpriteEx* make(wyTexture2D* pTex);
	
	/**
	 * 创建一个图像节点
	 *
	 * @param[in] pTex 贴图
	 * @param[in] r 指定使用的贴图区域，单位为像素
	 */
	static wySpriteEx* make(wyTexture2D* pTex, wyRect r);
	
	/**
	 * 通过\link wyZwoptexFrame wyZwoptexFrame\endlink 创建一个sprite
	 *
	 * @param pTex 贴图
	 * @param f \link wyZwoptexFrame wyZwoptexFrame\endlink 对象
	 */
	static wySpriteEx* make(wyTexture2D* pTex, wyZwoptexFrame* f);

	/**
	 * 创建一个图像节点, 启动批渲染模式
	 *
	 * @param[in] pBatchNode 父wySpriteBatch节点
	 * @param[in] r 指定使用的贴图区域，单位为像素
	 * @param zOrder sprite在batch node中的z order, 可选参数, 缺省是0
	 */
	static wySpriteEx* make(wySpriteBatchNode* pBatchNode, wyRect r, int zOrder = 0);
	
	/**
	 * 通过\link wyZwoptexFrame wyZwoptexFrame\endlink 创建一个图像节点, 启动批渲染模式
	 *
	 * @param[in] pBatchNode 父wySpriteBatch节点
	 * @param f \link wyZwoptexFrame wyZwoptexFrame\endlink 对象
	 * @param zOrder sprite在batch node中的z order, 可选参数, 缺省是0
	 */
	static wySpriteEx* make(wySpriteBatchNode* pBatchNode, wyZwoptexFrame* f, int zOrder = 0);

	/**
	 * 构造函数, 无贴图关联
	 */
	wySpriteEx();

	/**
	 * 构造函数
	 *
	 * @param[in] pTex 贴图
	 */
	wySpriteEx(wyTexture2D* pTex);
	
	/**
	 * 构造函数
	 *
	 * @param pTex 相关的图片或者图片集贴图对象
	 * @param r 指定使用的贴图区域，单位为像素
	 */
	wySpriteEx(wyTexture2D* pTex, wyRect r);
	
	/**
	 * 构造函数
	 *
	 * @param pTex 相关的图片或者图片集贴图对象
	 * @param f \link wyZwoptexFrame wyZwoptexFrame\endlink 对象
	 */
	wySpriteEx(wyTexture2D* pTex, wyZwoptexFrame* f);

	/// 析构函数
	virtual ~wySpriteEx();

	/// @see wyNode::addChild(wyNode*, int, int)
	virtual void addChild(wyNode* child, int z, int tag);

	/// 设置alpha值
	virtual void setAlpha(int alpha);

	/// 设置颜色
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);

	/// 获得贴图，两种模式均适用
	virtual wyTexture2D* getTexture();

	/// 设置贴图，两种模式均适用
	virtual void setTexture(wyTexture2D* tex);

	/// 设置是否绕Y中轴翻转
	virtual void setFlipX(bool flipX);
	
	/// 设置是否绕X中轴翻转
	virtual void setFlipY(bool flipY);

	/**
	 * 设置贴图区域
	 *
	 * @param[in] rt 贴图区域，单位为像素
	 */	
	void setTextureRect(wyRect rt);

	/**
	 * 设置Atlas索引, 这个方法主要是由\link wySpriteBatchNode wySpriteBatchNode\endlink, 除非你
	 * 非常清楚设置后的效果, 不然不要直接调用该方法
	 *
	 * @param index 新的atlas索引
	 */
	void setAtlasIndex(int index) { m_atlasIndex = index; }

	/**
	 * 获得Atlas索引
	 *
	 * @return atlas索引
	 */
	int getAtlasIndex() { return m_atlasIndex; }

	/**
	 * 设置父BatchNode节点, 一般只有WiEngine内部调用
	 *
	 * @param batchNode \link wySpriteBatchNode wySpriteBatchNode\endlink
	 */
	void setBatchNode(wySpriteBatchNode* batchNode);

	/**
	 * 设置是否启用批渲染模式, 一般只有WiEngine内部调用
	 *
	 * @param flag true表示启用批渲染模式, 设置为true时, batch node一定要被设置才有效
	 */
	void useBatchNode(bool flag) { m_useBatchNode = flag; }
};

#endif
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#ifndef __wySpriteFrame_h__

class wySpriteFrame : public wyFrame {
public:
	virtual ~wySpriteFrame();

	/**
	 * 通过贴图对象创建\link wySpriteFrame wySpriteFrame\endlink, 创建的
	 * 帧为整个贴图
	 *
	 * @param duration 持续时间
	 * @param tex \link wyTexture2D wyTexture2D\endlink
	 * @return \link wySpriteFrame wySpriteFrame\endlink
	 */
	static wySpriteFrame* make(float duration, wyTexture2D* tex);

	/**
	 * 通过矩形创建一个\link wySpriteFrame wySpriteFrame\endlink, 创建的帧的贴图应该属于某个
	 * 图片集
	 *
	 * @param duration 持续时间
	 * @param rect \link wyRect wyRect\endlink
	 * @return \link wySpriteFrame wySpriteFrame\endlink
	 */
	static wySpriteFrame* make(float duration, wyRect rect);

	/**
	 * 通过贴图对象创建\link wySpriteFrame wySpriteFrame\endlink, 并指定帧图片在
	 * 贴图中的范围
	 *
	 * @param duration 持续时间
	 * @param tex \link wyTexture2D wyTexture2D\endlink
	 * @param rect \link wyRect wyRect\endlink
	 * @return \link wySpriteFrame wySpriteFrame\endlink
	 */
	static wySpriteFrame* make(float duration, wyTexture2D* tex, wyRect rect);

	/**
	 * 通过贴图对象创建\link wySpriteFrame wySpriteFrame\endlink, 并指定帧图片在
	 * 贴图中的范围, 以及帧的偏移位置和原始大小
	 *
	 * @param duration 持续时间
	 * @param tex \link wyTexture2D wyTexture2D\endlink
	 * @param rect \link wyRect wyRect\endlink
	 * @param offset \link wyPoint wyPoint\endlink
	 * @param originalSize \link wySize wySize\endlink
	 * @return \link wySpriteFrame wySpriteFrame\endlink
	 */
	static wySpriteFrame* make(float duration, wyTexture2D* tex, wyRect rect, wyPoint offset, wySize originalSize);

	/**
	 * 通过贴图对象创建\link wySpriteFrame wySpriteFrame\endlink, 并指定帧图片在
	 * 贴图中的范围, 以及帧的偏移位置和原始大小
	 *
	 * @param duration 持续时间
	 * @param tex \link wyTexture2D wyTexture2D\endlink
	 * @param rect \link wyRect wyRect\endlink
	 * @param offset \link wyPoint wyPoint\endlink
	 * @param originalSize \link wySize wySize\endlink
	 * @param rotated true表示图片在图片集中顺时针旋转了90度
	 * @return \link wySpriteFrame wySpriteFrame\endlink
	 */
	static wySpriteFrame* make(float duration, wyTexture2D* tex, wyRect rect, wyPoint offset, wySize originalSize, bool rotated);

	wyRect getRect() { return m_rect; }
	void setRect(wyRect r) { m_rect = r; }
	wyRect getSourceColorRect() { return m_sourceColorRect; }
	void setSourceColorRect(wyRect r) { m_sourceColorRect = r; }
	wyPoint getOffset() { return m_offset; }
	void setOffset(wyPoint p) { m_offset = p; }
	wySize getOriginalSize() { return m_originalSize; }
	void setOriginalSize(wySize s) { m_originalSize = s; }
	wyTexture2D* getTexture() { return m_texture; }
	void setTexture(wyTexture2D* tex);
	void setRotated(bool flag) { m_rotated = flag; }
	bool isRotated() { return m_rotated; }
};

#endif // __wySpriteFrame_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyTextureNode_h__


/**
 * @class wyTextureNode
 *
 * 图片节点的封装. 如果一个贴图的大小和节点大小不符合，则贴图会被自动拉伸。在设置贴图时，
 * 节点大小会被设置成和贴图一样大，因此缺省情况下自动拉伸不会发生，如果需要（比如在设置
 * 一个背景图时），可以在设置贴图后再调用setContentSize修改节点大小，则可以起到拉伸
 * 贴图的效果。
 */
class wyTextureNode : public wyNode {
public:
	/**
	 * 静态构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 */
	static wyTextureNode* make(wyTexture2D* tex = NULL);

	/**
	 * 构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 */
	wyTextureNode(wyTexture2D* tex = NULL);

	/**
	 * 析构函数
	 */
	virtual ~wyTextureNode();

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_color.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha) { m_color.a = alpha; }

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);
	
	/// @see wyNode::getTexture
	virtual wyTexture2D* getTexture() { return m_tex; }

	/// @see wyNode::setTexture
	virtual void setTexture(wyTexture2D* tex);

	/**
	 * 指定所使用的贴图区域, 同时改变图片大小为当前贴图区域大小, 单位为像素.
	 * 贴图区域默认为整张图片,如需改变则调用此函数.
	 *
	 * @param[in] rect 矩形，(rect.x, rect.y)为左上角
	 */
	void setTextureRect(wyRect rect);

	/**
	 * 获得当前所使用的贴图区域,单位为像素.
	 *
	 * @return 矩形，(rect.x, rect.y)为左上角
	 */
	wyRect getTextureRect() { return m_texRect; }

	/// @see wyNode::addAnimation(wyAnimation*)
	virtual void addAnimation(wyAnimation* anim);

	/// @see wyNode::getAnimationById(int)
	virtual wyAnimation* getAnimationById(int id);

	/// @see wyNode::getDisplayFrame
	virtual wyFrame* getDisplayFrame();

	/// @see wyNode::isFrameDisplayed
	virtual bool isFrameDisplayed(wyFrame* frame) { return m_currentFrame == frame; }

	/// @see wyNode::setDisplayFrame
	virtual void setDisplayFrame(wyFrame* newFrame);

	/// @see wyNode::setDisplayFrameById
	virtual void setDisplayFrameById(int id, int frameIndex);

	/**
	 * 设置是否以Y轴为转动轴翻转图片
	 *
	 * @param flipX true为翻转
	 */
	void setFlipX(bool flipX) { m_flipX = flipX; }

	/**
	 * 获得是否以Y轴为转动轴翻转图片
	 *
	 * @return 是否以Y轴为转动轴翻转图片，true为翻转
	 */
	bool isFlipX() { return m_flipX; }

	/**
	 * 设置是否以X轴为转动轴翻转图片
	 *
	 * @param flipY true为翻转
	 */
	void setFlipY(bool flipY) { m_flipY = flipY; }

	/**
	 * 获得是否以X轴为转动轴翻转图片
	 *
	 * @return 是否以X轴为转动轴翻转图片，true为翻转
	 */
	bool isFlipY() { return m_flipY; }

	/**
	 * 设置图片来源是一个图片集，且被顺时针旋转了90度
	 *
	 * @param flag true表示图片来源是一个图片集，且被顺时针旋转了90度
	 */
	void setRotatedZwoptex(bool flag) { m_rotatedZwoptex = flag; }

	/**
	 * 是否图片来源是一个图片集，且被顺时针旋转了90度
	 *
	 * @return true表示图片来源是一个图片集，且被顺时针旋转了90度
	 */
	bool isRotatedZwoptex() { return m_rotatedZwoptex; }

	/**
	 * 设置是否自动拉伸贴图以便能匹配节点大小
	 *
	 * @param flag true表示自动拉伸贴图以便能匹配节点大小
	 */
	void setAutoFit(bool flag) { m_autoFit = flag; }

	/**
	 * 是否自动拉伸贴图以便能匹配节点大小
	 *
	 * @return true表示自动拉伸贴图以便能匹配节点大小
	 */
	bool isAutoFit() { return m_autoFit; }

	/**
	 * 将自身包装成一个\link wySpriteFrame wySpriteFrame\endlink, 生成的\link wySpriteFrame wySpriteFrame\endlink
	 * 的duration是0, 需要在返回后由开发者设置.
	 */
	wySpriteFrame* makeFrame();
};

#endif // __wyTextureNode_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyTGATileMapAtlas_h__


/**
 * @class wyTGATileMapAtlas
 *
 * TGA格式的瓦片地图。通过把图片中象素的R值映射到瓦片图片集中，形成地图
 */
class wyTGATileMapAtlas : public wyTileMapAtlas {
public:
	/**
	 * 静态构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param mapResId TGA资源id
	 * @param tileWidth 单个瓦片图片的象素宽度
	 * @param tileHeight 单个瓦片图片的象素高度
	 */
	static wyTGATileMapAtlas* make(wyTexture2D* tex, int mapResId, int tileWidth, int tileHeight);

	/**
	 * 构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param mapResId TGA资源id
	 * @param tileWidth 单个瓦片图片的象素宽度
	 * @param tileHeight 单个瓦片图片的象素高度
	 */
	wyTGATileMapAtlas(wyTexture2D* tex, int mapResId, int tileWidth, int tileHeight);

	/**
	 * 析构函数
	 */
	virtual ~wyTGATileMapAtlas();

	/// @see wyTileMapAtlas::hasTileAt
    virtual bool hasTileAt(int x, int y);

    /// @see wyTileMapAtlas::getHorizontalTileCount
    virtual int getHorizontalTileCount() { return m_tga->width; }

    /// @see wyTileMapAtlas::getVerticalTileCount
    virtual int getVerticalTileCount() { return m_tga->height; }

    /// @see wyTileMapAtlas::tileValueAt
    virtual int tileValueAt(int x, int y);
};

#endif // __wyTGATileMapAtlas_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyTiledSprite_h__


/**
 * @class wyTiledSprite
 *
 * 对一个贴图进行平铺, 可以用来做游戏背景。wyTiledSprite支持在水平和垂直方向进行贴图平铺，
 * 适合于构建平铺式背景。并且还提供了滚动和fling的方法，因此也适合于构建超大重复滚轴式背景。
 * wyTiledSprite的初始大小是和SurfaceView的大小一样.
 *
 * 缺省情况下wyTiledSprite将在水平和垂直方向都平铺贴图，如果设置在两个方向上都不平铺，则
 * 贴图会居中显示。平铺的方向也会影响到滚动时的处理，如果只设置了水平平铺，则垂直方向上不会
 * 发生滚动，如果设置了垂直平铺，则水平方向上不会发生滚动，如果两个方向都设置了平铺，则两个
 * 方向都可以滚动。
 */
class wyTiledSprite : public wyNode {
public:
	/**
	 * 静态构造函数。缺省情况下，wyTiledSprite节点和Surface一样大。
	 *
	 * @param tex 贴图对象，可以为NULL，之后可以通过setTexture再设置
	 */
	static wyTiledSprite* make(wyTexture2D* tex = NULL);

	/**
	 * 构造函数。缺省情况下，wyTiledSprite节点和Surface一样大。
	 *
	 * @param tex 贴图对象，可以为NULL，之后可以通过setTexture再设置
	 */
	wyTiledSprite(wyTexture2D* tex = NULL);

	/**
	 * 析构函数
	 */
	virtual ~wyTiledSprite();

	/**
	 * 得到是否垂直平铺标志
	 *
	 * @return true表示垂直方向进行平铺
	 */
	bool isTileVertical() { return m_tileVertical; }

	/**
	 * 得到是否水平平铺标志
	 *
	 * @return true表示水平方向进行平铺
	 */
	bool isTileHorizontal() { return m_tileHorizontal; }

	/**
	 * 设置平铺方向
	 *
	 * @param horizontal true表示水平方向进行平铺
	 * @param vertical true表示垂直方向进行平铺
	 */
	void setTileDirection(bool horizontal, bool vertical);

	/**
	 * 如果贴图代表了一个图片集，则可以设置要平铺的贴图在图片集中的矩形位置
	 *
	 * @param r 要平铺的贴图在图片集中的矩形位置，(x, y)代表贴图的左上角坐标
	 */
	void setTextureRect(wyRect r);

	/**
	 * 获得贴图的矩形，如果贴图是一个图片集，则这个方法可以获得实际绘制帧的矩形
	 *
	 * @return 贴图的矩形位置，对于图片集时有意义
	 */
	wyRect getTextureRect() { return m_rect; }

	/**
	 * 设置X方向的偏移量，为正时相当于把贴图向左移动，为负时相当于向右移动
	 *
	 * @param offset 偏移量
	 */
	void setOffsetX(int offset);

	/**
	 * 设置Y方向的偏移量，为正时相当于把贴图向上移动，为负时相当于向下移动
	 *
	 * @param offset 偏移量
	 */
	void setOffsetY(int offset);

	/**
	 * 调整偏移量
	 *
	 * @param dx X偏移量的调整值，会添加到现有偏移量上
	 * @param dy Y偏移量的调整值，会添加到现有偏移量上
	 */
	void offsetBy(int dx, int dy);

	/**
	 * 是否正在惯性移动中
	 *
	 * @return true表示正在惯性移动中
	 */
	bool isFlinging() { return m_flinging; }

	/**
	 * 设置最大的x方向偏移量
	 *
	 * @param max 最大x方向偏移量
	 */
	void setMaxOffsetX(int max) { m_maxOffsetX = max; }

	/**
	 * 得到最大x方向偏移量
	 *
	 * @return 最大x方向偏移量
	 */
	int getMaxOffsetX() { return m_maxOffsetX; }

	/**
	 * 设置最小的x方向偏移量
	 *
	 * @param min 最小x方向偏移量
	 */
	void setMinOffsetX(int min) { m_minOffsetX = min; }

	/**
	 * 得到最小x方向偏移量
	 *
	 * @return 最小x方向偏移量
	 */
	int getMinOffsetX() { return m_minOffsetX; }

	/**
	 * 设置最大的y方向偏移量
	 *
	 * @param max 最大y方向偏移量
	 */
	void setMaxOffsetY(int max) { m_maxOffsetY = max; }

	/**
	 * 得到最大y方向偏移量
	 *
	 * @return 最大y方向偏移量
	 */
	int getMaxOffsetY() { return m_maxOffsetY; }

	/**
	 * 设置最小的y方向偏移量
	 *
	 * @param min 最小y方向偏移量
	 */
	void setMinOffsetY(int min) { m_minOffsetY = min; }

	/**
	 * 得到最小y方向偏移量
	 *
	 * @return 最小y方向偏移量
	 */
	int getMinOffsetY() { return m_minOffsetY; }

	/**
	 * 中止fling，如果当前没有在fling，则不做任何事
	 */
	void stopFling();

	/**
	 * 开始fling, 如果当前正在fling，则不做任何事.
	 *
	 * @param velocityX x方向的fling速度, 如果没有设置水平平铺，则被忽略
	 * @param velocityY y方向的fling速度, 如果没有设置垂直平铺，则被忽略
	 */
	void fling(float velocityX, float velocityY);
	
	/**
	 * 设置是否在不平铺的方向上拉伸贴图, 比如贴图在水平方向上平铺, 垂直方向上不平铺,
	 * 则设置此标志为true可以让贴图在垂直方向上充满节点大小
	 *
	 * @param flag true表示在不平铺的方向上拉伸贴图
	 */
	void setStretch(bool flag) { m_stretch = flag; }

	/**
	 * 是否在不平铺的方向上拉伸贴图
	 *
	 * @return true表示在不平铺的方向上拉伸贴图
	 */
	bool isStretch() { return m_stretch; }

	/**
	 * 设置平铺的间隔
	 *
	 * @param x 水平方向间隔, 如果没有设置在水平方向上平铺则不起作用
	 * @param y 垂直方向间隔, 如果没有设置在水平方向上平铺则不起作用
	 */
	void setSpacing(float x, float y);

	/**
	 * 得到水平方向平铺间隔
	 *
	 * @return 水平方向平铺间隔
	 */
	float getSpacingX() { return m_spacingX; }

	/**
	 * 得到垂直方向平铺间隔
	 *
	 * @return 垂直方向平铺间隔
	 */
	float getSpacingY() { return m_spacingY; }
	
	/**
	 * \if English
	 * Is dither enabled?
	 *
	 * @return true means dither is enabled
	 * \else
	 * 是否打开抖动
	 *
	 * @return true表示打开抖动, false表示不打开抖动
	 * \endif
	 */
	bool isDither() { return m_dither; }

	/**
	 * \if English
	 * Set dither enabled or not
	 *
	 * @param flag true means enable dither, falose means not
	 * \else
	 * 设置是否打开抖动
	 *
	 * @param flag true表示打开抖动, false表示不打开抖动
	 * \endif
	 */
	void setDither(bool flag) { m_dither = flag; }
};

#endif // __wyTiledSprite_h__
/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyTileMapAtlas_h__


/**
 * @class wyTileMapAtlas
 *
 * 瓦片地图抽象基类. 其瓦片的坐标用(x, y)表示，每个瓦片都有一个值，这个值会映射到一个
 * 图片集中的图片。瓦片的坐标采用OpenGL坐标系，即(0, 0)表示的是左下角。
 */
class wyTileMapAtlas : public wyAtlasNode {
public:
    /**
	 * 构造函数
	 *
	 * @param tex 图片资源\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param tileWidth 单个瓦片的象素宽度
	 * @param tileHeight 单个瓦片的象素高度
	 */
    wyTileMapAtlas(wyTexture2D* tex, int tileWidth, int tileHeight);

    /**
	 * 析构函数
	 */
    virtual ~wyTileMapAtlas();

    /**
	 * 检查在指定行列位置是否有瓦片
	 *
	 * @param x 行位置
	 * @param y 列位置
	 * @return true表示有，false表示该位置没有映射到任何瓦片图片上
	 */
    virtual bool hasTileAt(int x, int y) = 0;

    /**
	 * 得到水平方向上的瓦片数
	 *
	 * @return 水平方向上的瓦片数
	 */
    virtual int getHorizontalTileCount() = 0;

    /**
	 * 得到垂直方向上的瓦片数
	 *
	 * @return 垂直方向上的瓦片数
	 */
    virtual int getVerticalTileCount() = 0;

    /**
	 * 得到某个行列坐标上的原始瓦片值，瓦片值如何映射到瓦片图片由子类实现决定
	 *
	 * @param x 行位置
	 * @param y 列位置
	 * @return 瓦片原始值
	 */
    virtual int tileValueAt(int x, int y) = 0;

    /**
	 * 得到某个行列位置的瓦片值
	 *
	 * @param x x坐标
	 * @param y y坐标
	 * @return 原始瓦片值，瓦片值如何映射到瓦片图片由子类实现决定
	 */
	int getTile(int x, int y);

	/**
	 * 设置某个行列位置的瓦片值
	 *
	 * @param tileValue 原始瓦片值，瓦片值如何映射到瓦片图片由子类实现决定
	 * @param x x坐标
	 * @param y y坐标
	 */
	void setTile(int tileValue, int x, int y);
};

#endif // __wyTileMapAtlas_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyStripRibbon_h__

/**
 * @class wyStripRibbon
 *
 * 等宽条状带，它渲染一个连续的，等宽的条。
 */
class wyStripRibbon : public wyRibbon {
public:
    /**
	 * 静态构造函数
	 *
	 * @param tex 贴图\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图渲染颜色
	 * @param fade 淡出时间, 传入0表示不淡出一直保持，直到用reset清除
	 */
    static wyStripRibbon* make(wyTexture2D* tex, wyColor4B color, float fade);

    /**
	 * 构造函数
	 *
	 * @param tex 贴图\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图渲染颜色
	 * @param fade 淡出时间, 传入0表示不淡出一直保持，直到用reset清除
	 */
    wyStripRibbon(wyTexture2D* tex, wyColor4B color, float fade);

    /**
	 * 析构函数
	 */
    virtual ~wyStripRibbon();

	/// @see wyNode::getTexture
	virtual wyTexture2D* getTexture() { return m_atlas->getTexture(); }

	/// @see wyNode::setTexture
	virtual void setTexture(wyTexture2D* tex);

	/**
	 * 被Scheduler调用的方法，不要手动调用
	 *
	 * @param delta 帧刷新的间隔时间
	 */
	virtual void update(float delta);

	/**
	 * 添加一个新端点
	 *
	 * @param location 顶点\link wyPoint wyPoint对象指针\endlink
	 */
	virtual void addPoint(wyPoint location);

	/**
	 * 重置ribbon，清除当前的点，擦除所有绘制内容
	 */
	virtual void reset();
};

#endif // __wyStripRibbon_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wySpotRibbon_h__

/**
 * @class wySpotRibbon
 *
 * 绘制一个不连续的点状带。这里说的点其实就是一个完整的贴图，并不是指一个像素点。这个渲染
 * 的效果类似于愤怒小鸟中的那种轨迹效果。
 */
class wySpotRibbon : public wyRibbon {
public:
    /**
	 * 静态构造函数
	 *
	 * @param tex 贴图\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图渲染颜色
	 * @param fade 淡出时间, 传入0表示不淡出一直保持，直到用reset清除
	 */
    static wySpotRibbon* make(wyTexture2D* tex, wyColor4B color, float fade);

    /**
	 * 构造函数
	 *
	 * @param tex 贴图\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图渲染颜色
	 * @param fade 淡出时间, 传入0表示不淡出一直保持，直到用reset清除
	 */
    wySpotRibbon(wyTexture2D* tex, wyColor4B color, float fade);

    /**
	 * 析构函数
	 */
    virtual ~wySpotRibbon();

	/// @see wyNode::getTexture
	virtual wyTexture2D* getTexture() { return m_atlas->getTexture(); }

	/// @see wyNode::setTexture
	virtual void setTexture(wyTexture2D* tex);

	/**
	 * 被Scheduler调用的方法，不要手动调用
	 *
	 * @param delta 帧刷新的间隔时间
	 */
	virtual void update(float delta);

	/**
	 * 添加一个新端点
	 *
	 * @param location 顶点\link wyPoint wyPoint对象指针\endlink
	 */
	virtual void addPoint(wyPoint location);

	/**
	 * 重置ribbon，清除当前的点，擦除所有绘制内容
	 */
	virtual void reset();

	/**
	 * 设置渲染间隔，仅用于非连续渲染模式
	 *
	 * @param d 贴图渲染之间的间隔
	 */
	void setDistance(float d) { m_distance = d; }

	/**
	 * 得到渲染间隔，仅用于非连续渲染模式
	 *
	 * @return 渲染间隔
	 */
	float getDistance() { return m_distance; }
};

#endif // __wySpotRibbon_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyBladeRibbon_h__

/**
 * @class wyBladeRibbon
 *
 * 绘制一个连续的，不等宽的条状带，头部还带有箭头效果。其效果类似于水果忍者
 * 中的刀痕，因此叫做blade ribbon
 */
class wyBladeRibbon : public wyRibbon {
public:
    /**
	 * 静态构造函数
	 *
	 * @param tex 贴图\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图渲染颜色
	 * @param fade 淡出时间, 传入0表示不淡出一直保持，直到用reset清除
	 */
    static wyBladeRibbon* make(wyTexture2D* tex, wyColor4B color, float fade);

    /**
	 * 析构函数
	 */
    virtual ~wyBladeRibbon();

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_color.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha);

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);

	/// @see wyNode::getTexture
	virtual wyTexture2D* getTexture() { return m_texture; }

	/// @see wyNode::setTexture
	virtual void setTexture(wyTexture2D* tex);

	/**
	 * 被Scheduler调用的方法，不要手动调用
	 *
	 * @param delta 帧刷新的间隔时间
	 */
	virtual void update(float delta);

	/**
	 * 添加一个新端点
	 *
	 * @param location 顶点\link wyPoint wyPoint对象指针\endlink
	 */
	virtual void addPoint(wyPoint location);

	/**
	 * 重置ribbon，清除当前的点，擦除所有绘制内容
	 */
	virtual void reset();

	/**
	 * 设置最大点数限制, 缺省是50个
	 *
	 * @param max 最大点数限制
	 */
	void setMaxPointCount(int max);

	/**
	 * 得到最大点数限制
	 *
	 * @return 最大点数限制
	 */
	int getMaxPointCount() { return m_maxPointCount; }
};

#endif // __wyBladeRibbon_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyLineRibbon_h__

/**
 * @class wyLineRibbon
 *
 * 线状连续图形，等宽，头尾有圆角效果
 */
class wyLineRibbon : public wyRibbon {
public:
    /**
	 * 静态构造函数
	 *
	 * @param tex 贴图\link wyTexture2D wyTexture2D对象指针\endlink
	 * @param color 贴图渲染颜色
	 */
    static wyLineRibbon* make(wyTexture2D* tex, wyColor4B color);

    /**
	 * 析构函数
	 */
    virtual ~wyLineRibbon();

	/// @see wyNode::getTexture
	virtual wyTexture2D* getTexture() { return m_tex; }

	/// @see wyNode::setTexture
	virtual void setTexture(wyTexture2D* tex);

	/// @see wyNode::getAlpha
	virtual int getAlpha() { return m_color.a; }

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha) { m_color.a = alpha; }

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);

    /// @see wyRibbon::update
	virtual void update(float delta);

	/// @see wyRibbon::addPoint
	virtual void addPoint(wyPoint location);

	/// @see wyRibbon::reset
	virtual void reset();

	/**
	 * 设置线宽，如果不设置，则缺省为贴图的有效高度. 该设置不影响已经存在的线. 设置之后创建的
	 * 线将变成该宽度
	 *
	 * @param width 线宽, 单位像素
	 */
	void setLineWidth(float width);

	/**
	 * 得到某条线的宽度
	 *
	 * @param index 线的索引
	 * @return 线的宽度, 单位像素. 如果索引不合法，返回0
	 */
	float getLineWidth(int index);

	/**
	 * 得到某条线的颜色
	 *
	 * @param index 线的索引
	 * @return \link wyColor4B wyColor4B\endlink
	 */
	wyColor4B getLineColor(int index);
	
	/**
	 * 得到线的个数
	 *
	 * @return 线段的个数
	 */
	int getLineCount() { return m_lines->num; }

	/**
	 * 得到某条线的点个数
	 *
	 * @param index 线的索引
	 * @return 线的点个数. 如果索引不合法，返回0
	 */
	int getLinePointCount(int index);

	/**
	 * 得到线的点列表
	 *
	 * @param index 线的索引
	 * @return \link wyPoint wyPoint\endlink指针，调用者不需要负责释放. 如果索引不合法，返回NULL
	 */
	wyPoint* getLinePointList(int index);
};

#endif // __wyLineRibbon_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyPageIndicator_h__


/**
 * @class wyPageIndicator
 *
 * \link wyPageControl wyPageControl\endlink中的页面指示组件, 它是一个虚类, 可以通过
 * 继承实现不同风格的页面指示组件. 如果一个\link wyPageControl wyPageControl\endlink指定
 * 了一个页面指示组件, 则页面指示节点会是\link wyPageControl wyPageControl\endlink的子
 * 节点
 */
class wyPageIndicator : public wyNode {
};

#endif // __wyPageIndicator_h__


/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyDotPageIndicator_h__

/**
 * @class wyDotPageIndicator
 *
 * 点状页面指示节点, 最传统的一种页面指示节点. 创建这个节点时, 指定两个图片分别表示页面没选中和
 * 选中的状态.
 */
class wyDotPageIndicator : public wyPageIndicator {
public:
	/**
	 * 静态构造函数
	 *
	 * @param dot 页面没有被选中时的图片, 不能为NULL
	 * @param selectedDot 页面被选中时的图片, 不能为NULL
	 * @return \link wyDotPageIndicator wyDotPageIndicator\endlink
	 */
	static wyDotPageIndicator* make(wyTexture2D* dot, wyTexture2D* selectedDot);

	/**
	 * 静态构造函数
	 *
	 * @param dot 页面没有被选中时的图片, 不能为NULL
	 * @param dotRect 如果dot是一个图片集, 则表示点图片在图片集中的位置
	 * @param selectedDot 页面被选中时的图片, 不能为NULL
	 * @param selectedDotRect 如果selectedDot是一个图片集, 则表示选中的点图片在图片集中的位置
	 * @return \link wyDotPageIndicator wyDotPageIndicator\endlink
	 */
	static wyDotPageIndicator* make(wyTexture2D* dot, wyRect dotRect, wyTexture2D* selectedDot, wyRect selectedDotRect);

	virtual ~wyDotPageIndicator();

	void setDotSpacing(float spacing) { m_dotSpacing = spacing; }
	float getDotSpacing() { return m_dotSpacing; }
};

#endif // __wyDotPageIndicator_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyAnimation_h__


class wyAnimate;
class wyAnimation;

/**
 * @struct wyAnimationCallback
 *
 * 动画回调定义。\link wyAnimation wyAnimation\endlink 本身并不会
 * 自动运行，需要结合\link wyAnimate wyAnimate\endlink 使用时，这些
 * 回调会被\link wyAnimate wyAnimate\endlink 调用。
 */
typedef struct wyAnimationCallback {
} wyAnimationCallback;

/**
 * @class wyAnimation
 *
 * 动画的封装, 设置动画的帧和持续时间
 */
class wyAnimation : public wyObject {

public:
	/**
	 * 静态构造函数
	 *
	 * @param id 动画id
	 */
	static wyAnimation* make(int id);

	/**
	 * 析构函数
	 */
	virtual ~wyAnimation();

	/**
	 * 动画接口实现: 得到动画总持续时间
	 *
	 * @return 动画总持续时间
	 */
	float getDuration() { return m_duration; }

	/**
	 * 动画接口实现: 获得帧列表
	 *
	 * @return 帧对象数组
	 */
	wyArray* getFrames() { return m_frames; }

	/**
	 * 动画接口实现: 得到动画id。为了区分动画，可以给动画一个id
	 *
	 * @return 动画id
	 */
	int getId() { return m_id; }

	/**
	 * 添加一帧动画
	 *
	 * @param frameDuration 所添加的帧持续的时间
	 * @param tex \link wyTexture2D wyTexture2D对象 \endlink 指针
	 */
	void addFrame(float frameDuration, wyTexture2D* tex);

	/**
	 * 添加一帧动画, 帧的图片是图片集中的一部分
	 *
	 * @param frameDuration 所添加的帧持续的时间
	 * @param rect 帧图片在图片集中的矩形
	 */
	void addFrame(float frameDuration, wyRect rect);

	/**
	 * 添加一帧动画
	 *
	 * @param f \link wyFrame wyFrame\endlink
	 */
	void addFrame(wyFrame* f);

	/**
	 * 设置回调
	 *
	 * @param callback \link wyAnimationCallback wyAnimationCallback\endlink 结构指针
	 * @param data 额外数据指针
	 */
	void setCallback(wyAnimationCallback* callback, void* data);
};

#endif //__wyAnimation_h__

#ifndef __wyPageControl_h__


class wyPageControl;

/**
 * @struct wyPageControlCallback
 *
 * page control的回调方法
 */
typedef struct wyPageControlCallback {
} wyPageControlCallback;

/**
 * 类似于iPhone中的PageControl, 提供一个水平滚动的列表. 里面的每一项
 * 是一个\link wyNode wyNode\endlink 的子类
 */
class wyPageControl : public wyNode {
public:
	static wyPageControl* make();

	wyPageControl();
	virtual ~wyPageControl();

	/// @see wyNode::touchesBegan
	virtual bool touchesBegan(wyMotionEvent& e);

	/// @see wyNode::touchesMoved
	virtual bool touchesMoved(wyMotionEvent& e);

	/// @see wyNode::touchesEnded
	virtual bool touchesEnded(wyMotionEvent& e);

	/// @see wyNode::touchesCancelled
	virtual bool touchesCancelled(wyMotionEvent& e);

	/// @see wyNode::onFling
	virtual bool onFling(wyMotionEvent& e1, wyMotionEvent& e2, float velocityX, float velocityY);

	/**
	 * 添加一页
	 *
	 * @param page \link wyNode wyNode\endlink
	 */
	void addPage(wyNode* page);

	/**
	 * 在指定位置添加一页
	 *
	 * @param page \link wyNode wyNode\endlink
	 * @param index 指定要添加到的位置, 如果超过有效范围, 则不做任何事
	 */
	void addPageAt(wyNode* page, int index);

	/**
	 * 删除一页
	 *
	 * @param page \link wyNode wyNode\endlink
	 */
	void removePage(wyNode* page);

	/**
	 * 删除指定位置的页
	 *
	 * @param index 页索引，如果超出范围则无效果
	 */
	void removePageAt(int index);

	/**
	 * 删除所有页
	 */
	void removeAllPages();

	/**
	 * 设置初始页，该方法可用来初始化当前显示的页。这个方法不会触发page
	 * changed回调。使用这个方法设置页没有滚动的动画效果，因此只适合
	 * 在创建时期初始化page control.
	 */
	void setInitialPage(int index);
	
	/**
	 * 切换到某页
	 *
	 * @param index 要切换到的页
	 * @param animate true表示需要附带切换的动画效果, false表示不需要. 缺省是false
	 * @param duration 切换动画效果的持续时间, 仅当animate为true时有效. 缺省值是1秒.
	 */
	void gotoPage(int index, bool animate = false, float duration = 1.0f);

	/**
	 * 设置页间的间隔
	 *
	 * @param spacing 页之间的间隔
	 */
	void setPageSpacing(float spacing);

	/**
	 * 获得页间的间隔
	 *
	 * @return 页之间的间隔
	 */
	float getPageSpacing() { return m_pageSpacing; }

	/**
	 * 获得页在垂直位置的中心
	 *
	 * @return 垂直位置的中心
	 */
	float getCenterY() { return m_centerY; }

	/**
	 * 设置垂直位置的中心
	 *
	 * @param y 垂直位置的中心
	 */
	void setCenterY(float y) { m_centerY = y; }

	/**
	 * 获得页在水平位置的中心, 仅适用于垂直型布局
	 *
	 * @return 水平位置的中心
	 */
	float getCenterX() { return m_centerX; }

	/**
	 * 设置水平位置的中心, 仅适用于垂直型布局
	 *
	 * @param x 水平位置的中心
	 */
	void setCenterX(float x) { m_centerX = x; }
	
	/**
	 * 得到页数
	 *
	 * @return 页数
	 */
	int getPageCount() { return m_pages->num; }

	/**
	 * 设置回调
	 *
	 * @param callback \link wyPageControlCallback wyPageControlCallback\endlink 结构指针, callback的内容
	 * 		会被复制，因此\link wyPageControl wyPageControl\endlink 不会负责释放该指针。如果指针为NULL，表示清
	 * 		除之前设置的回调
	 * @param data 附加数据指针, \link wyPageControl wyPageControl\endlink 不会负责释放该指针
	 */
	void setCallback(wyPageControlCallback* callback, void* data);


	/**
	 * 是否垂直排列页
	 *
	 * @return true表示垂直排列页
	 */
	bool isVertical() { return m_vertical; }

	/**
	 * 设置是否垂直排列页
	 *
	 * @param flag true表示垂直排列页
	 */
	void setVertical(bool flag);
};

#endif // __wyPageControl_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyTextBox_h__

/**
 * @struct wyTextBoxCallback
 *
 * \if English
 * Definition of edit text event callback
 * \else
 * \link wyTextBox wyTextBox\endlink 的回调接口定义
 * \endif
 */
typedef struct wyTextBoxCallback {
} wyTextBoxCallback;

/**
 * @class wyTextBox
 *
 * 提供一个单行文本编辑框组件，wyTextBox是一个组合式节点，它是由4个状态节点和一个标签节点组合
 * 而成的。四个状态和\link wyButton wyButton\endlink一样，是普通，焦点，按下，禁止四态，
 * 只有普通态是必须提供的，其它的都可以为NULL。标签节点是用来显示用户输入的问题的，只要是
 * WiEngine支持的标签节点都可以，或者通泛一点说，只要是实现了\link wyNode wyNode\endlink
 * 中set/getText方法的子类都可以。标签节点显示的范围不会超过文本框状态图片的范围。<br/>
 *
 * 文本框节点的大小在创建后会自动根据状态图片的大小决定，当然您也可以手动设置大小，但是不建议这么
 * 做，因为自动计算出的大小是最佳大小。<br/>
 *
 * 文本框编辑的是采用弹框式，因为在手机上可能存在软键盘，当软键盘出现时，有可能会遮挡文本框
 * 节点，因此采用弹框式的设计更容易让用户输入。可以设置弹出框的标题和提示。<br/>
 *
 * 文本框缺省是打开了触摸事件处理的.
 */
class wyTextBox : public wyNode {
public:
	/**
	 * 静态构造函数
	 *
	 * @param normal 正常状态的\link wyNode wyNode对象指针 \endlink, 不能为NULL
	 * @param selected 被选中状态的\link wyNode wyNode对象指针 \endlink，可以为NULL
	 * @param disabled 禁用状态的\link wyNode wyNode对象指针 \endlink，可以为NULL
	 * @param focused  获得焦点状态的\link wyNode wyNode对象指针 \endlink，可以为NULL
	 * @param label 文字标签节点，只要是WiEngine中支持的标签节点都可以，比如\link wyLabel wyLabel\endlink,
	 * 		\link wyAtlasLabel wyAtlasLabel\endlink, \link wyBitmapFontLabel wyBitmapFontLabel\endlnk等
	 */
	static wyTextBox* make(wyNode* normal, wyNode* selected, wyNode* disabled, wyNode* focused, wyNode* label);

	virtual ~wyTextBox();

	/// @see wyNode::onEnter
	virtual void onEnter();

	/// @see wyNode::onExit
	virtual void onExit();

	/// @see wyNode::getText
	virtual const char* getText();

	/// @see wyNode::setText
	virtual void setText(const char* text);

	/// @see wyNode::getColor
	virtual wyColor3B getColor();

	/// @see wyNode::setColor
	virtual void setColor(wyColor3B color);

	/// @see wyNode::setColor
	virtual void setColor(wyColor4B color);

	/// @see wyNode::getAlpha
	virtual int getAlpha();

	/// @see wyNode::setAlpha
	virtual void setAlpha(int alpha);

	/**
	 * \if English
	 * Set callback
	 *
	 * @param callback \link wyTextBoxCallback wyTextBoxCallback\endlink structure. NULL means clear current callback.
	 * @param data User data pointer, who allocate it should be responsible for release it
	 * \else
	 * 设置动作执行的回调函数native引用
	 *
	 * @param callback 回调函数\link wyTextBoxCallback wyTextBoxCallback\endlink结构, 如果
	 * 		为NULL, 则表示清除现有的callback
	 * @param data 附加数据指针，wyTextBox不会负责释放该指针
	 * \endif
	 */
	void setCallback(wyTextBoxCallback* callback, void* data);

	/**
	 * 设置弹出框的标题
	 *
	 * @param title 标题字符串, 这个字符串会被复制，因此方法返回后可以立刻释放
	 */
	void setTitle(const char* title);

	/**
	 * 获得弹出框的标题
	 *
	 * @return 弹出框的标题字符串, 调用者不需要负责释放
	 */
	const char* getTitle() { return m_title; }

	/**
	 * 设置弹出框的提示，这个提示不要超过3行，不然在iOS上会显示不下.
	 *
	 * @param msg 提示字符串, 这个字符串会被复制，因此方法返回后可以立刻释放
	 */
	void setMessage(const char* msg);

	/**
	 * 获得弹出框的提示
	 *
	 * @return 弹出框的提示字符串, 调用者不需要负责释放
	 */
	const char* getMessage() { return m_message; }

	/**
	 * 设置弹出框的确定按钮文字
	 *
	 * @param btn 确定按钮文字字符串, 这个字符串会被复制，因此方法返回后可以立刻释放
	 */
	void setPositiveButton(const char* btn);

	/**
	 * 获得弹出框的确定按钮文字
	 *
	 * @return 弹出框的确定按钮文字, 调用者不需要负责释放
	 */
	const char* getPositiveButton() { return m_positiveButton; }

	/**
	 * 设置弹出框的取消按钮文字
	 *
	 * @param btn 取消按钮文字字符串, 这个字符串会被复制，因此方法返回后可以立刻释放
	 */
	void setNegativeButton(const char* btn);

	/**
	 * 获得弹出框的取消按钮文字
	 *
	 * @return 弹出框的取消按钮文字, 调用者不需要负责释放
	 */
	const char* getNegativeButton() { return m_negativeButton; }

	/**
	 * 当确定按钮被按下时被调用，主要由内部调用
	 *
	 * @param text 新的字符串
	 */
	void onPositiveButtonClicked(const char* text);

	/**
	 * 当取消按钮被按下时被调用，主要由内部调用
	 */
	void onNegativeButtonClicked();

	/**
	 * 当文字输入改变时调用，主要由内部调用。由于采用的是弹框式输入方法，
	 * 所以实际上是在对话框中输入改变时会调用这个方法。
	 *
	 * @param newText 改变后的字符串
	 */
	void onTextChanged(const char* newText);

	/**
	 * 设置文本框矩形和标签节点之间的空隙. 默认都是0.
	 *
	 * @param left 左边间隔
	 * @param top 上边间隔
	 * @param right 右边间隔
	 * @param bottom 下边间隔
	 */
	void setPadding(float left, float top, float right, float bottom);
};

#endif // __wyTextBox_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyScrollableLayerListener_h__

/**
 * @typedef wyScrollableLayerListener
 *
 * \if English
 * Scrollablelayer event interface
 * \else
 * 滚动层回调定义
 * \endif
 */
class wyScrollableLayerListener {
public:
	/**
	 * 当滚动层的偏移位置发生变化时被调用, 可以通过getOffsetX, getOffsetY方法获得当前的位置.
	 *
	 * @param layer \link wyScrollableLayer wyScrollableLayer\endlink
	 */
	virtual void onScrollOffsetChanged(wyScrollableLayer* layer) {}

	/**
	 * 当正要开始抛掷时被调用, 在抛掷结束前, onScrollOffsetChanged会被持续触发. 但是
	 * 要注意onScrollOffsetChanged在没有抛掷时也会发生, 只要偏移改变就会发生
	 *
	 * @param layer \link wyScrollableLayer wyScrollableLayer\endlink
	 */
	virtual void onStartFling(wyScrollableLayer* layer) {}

	/**
	 * 当抛掷结束时被调用
	 *
	 * @param layer \link wyScrollableLayer wyScrollableLayer\endlink
	 */
	virtual void onEndFling(wyScrollableLayer* layer) {}

	/**
	 * \if English
	 * Invoked for every scrollable child when it is outside of scrollable layer area.
	 * You can do some resource releasing in this method, and it is critical if your
	 * have many many textures in scrollablelayer.
	 *
	 * @param layer \link wyScrollableLayer wyScrollableLayer\endlink
	 * @param child child node which is outside scrollable layer area
	 * \else
	 * 当一个可滚动节点离开了可见滚动区域时被调用, 在这个方法里可以做一些资源释放工作. 如果一个可
	 * 滚动层里非常多的贴图, 则及时的释放那些不可见的贴图是很重要的.
	 *
	 * @param layer \link wyScrollableLayer wyScrollableLayer\endlink
	 * @param child 离开了可见滚动区域的节点
	 * \endif
	 */
	virtual void onScrollableChildNotVisible(wyScrollableLayer* layer, wyNode* child) {}
};

#endif // __wyScrollableLayerListener_h__


/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyScrollableLayer_h__

/**
 * @class wyScrollableLayer
 *
 * 提供一个可滚动的层, 类似于Android中的ScrollView. wyScrollableLayer支持水平或垂直
 * 或双方向滚动. 创建后应该调用setVertical或setHorizontal设置是否允许滚动. 如果想
 * 往wyScrollableLayer中添加子节点, 应该调用addScrollableChildLocked而不是addChildLocked.
 * 因为addChildLocked是直接往wyScrollableLayer中添加节点, 是不会被滚动的.
 */
class wyScrollableLayer : public wyColorLayer {
public:
	/**
	 * 静态构造函数
	 *
	 * @param color 颜色\link wyColor4B wyColor4B结构\endlink
	 * @return \link wyScrollableLayer wyScrollableLayer\endlink
	 */
	static wyScrollableLayer* make(wyColor4B color);

	/**
	 * 构造函数
	 *
	 * @param color 颜色\link wyColor4B wyColor4B结构\endlink
	 */
	wyScrollableLayer(wyColor4B color);

	/**
	 * 析构函数
	 */
	virtual ~wyScrollableLayer();

	/// @see wyNode::setContentSize
	virtual void setContentSize(float w, float h);

	/// @see wyNode::touchesBegan
	virtual bool touchesBegan(wyMotionEvent& e);

	/// @see wyNode::touchesMoved
	virtual bool touchesMoved(wyMotionEvent& e);

	/// @see wyNode::touchesEnded
	virtual bool touchesEnded(wyMotionEvent& e);

	/// @see wyNode::touchesCancelled
	virtual bool touchesCancelled(wyMotionEvent& e);

	/// @see wyNode::onFling
	virtual bool onFling(wyMotionEvent& e1, wyMotionEvent& e2, float velocityX, float velocityY);

	/**
	 * 设置是否允许垂直滚动, 缺省是false
	 *
	 * @param flag true表示允许垂直滚动
	 */
	void setVertical(bool flag) { m_vertical = flag; }

	/**
	 * 是否允许垂直滚动
	 *
	 * @return true表示允许垂直滚动
	 */
	bool isVertical() { return m_vertical; }

	/**
	 * 设置是否允许水平滚动, 缺省是false
	 *
	 * @param flag true表示允许水平滚动
	 */
	void setHorizontal(bool flag) { m_horizontal = flag; }

	/**
	 * 是否允许水平滚动
	 *
	 * @return true表示允许水平滚动
	 */
	bool isHorizontal() { return m_horizontal; }

	/**
	 * 添加可滚动子节点,方法是线程安全的
	 *
	 * @param child 子节点\link wyNode wyNode对象指针\endlink
	 * @param z z轴顺序, 缺省是0
	 * @param tag 子节点的标识, 缺省是一个无效值
	 */
	void addScrollableChildLocked(wyNode* child, int z = 0, int tag = INVALID_TAG);

	/**
	 * 删除某个子节点,方法是线程安全的
	 *
	 * @param child 要删除的节点
	 * @param cleanup true表示重置被删除的节点的状态。一个节点被clean之后将失去一些状态，比如附加在节点
	 * 		上的action，timer等，但是这个节点仍然可以用addChild加回来继续使用。
	 */
	void removeScrollableChildLocked(wyNode* child, bool cleanup);

	/**
	 * 根据tag删除某个子节点,方法是线程安全的
	 *
	 * @param tag 子节点的tag
	 * @param cleanup true表示重置被删除的节点的状态。一个节点被clean之后将失去一些状态，比如附加在节点
	 * 		上的action，timer等，但是这个节点仍然可以用addChild加回来继续使用。
	 */
	void removeScrollableChildByTagLocked(int tag, bool cleanup);

	/**
	 * \if English
	 * Get a scrollable child by tag. This method can only be used to get child which
	 * is added by \c addScrollableChildLocked
	 *
	 * @param tag child tag
	 * @return child node, or NULL if no such child node
	 * \else
	 * 根据tag得到某个可滚动子节点, 这个方法仅能用来得到通过\c addScrollableChildLocked方法添加的
	 * 子节点
	 *
	 * @param tag 子节点tag
	 * @return 子节点, 如果没有找到则返回NULL
	 * \endif
	 */
	wyNode* getScrollableChildByTag(int tag);
	
	/**
	 * 得到当前可滚动区域的大小，这个方法必须在\c addScrollableChildLocked 之后调用，
	 * 因为\c addScrollableChildLocked 会让可滚动区域重新计算, 会导致之前获得的大小
	 * 不再正确
	 *
	 * @return 可滚动区域大小
	 */
	wySize getScrollExtent();

	/**
	 * 设置水平滚动条节点。缺省是没有的，即水平滚动的时候并没有一个可见的滚动条. 可以设置任意\link wyNode wyNode\endlink
	 * 的子类为水平滚动条，如果这个节点是一个\link wyNinePatchSprite wyNinePatchSprite\endlink对象，则其会根据
	 * 可视范围进行相应的拉伸。
	 *
	 * @param thumb 用作水平滚动条的\link wyNode wyNode\endlink对象, NULL表示要去掉水平滚动条
	 */
	void setHorizontalThumb(wyNode* thumb);

	/**
	 * 设置垂直滚动条节点。缺省是没有的，即垂直滚动的时候并没有一个可见的滚动条. 可以设置任意\link wyNode wyNode\endlink
	 * 的子类为垂直滚动条，如果这个节点是一个\link wyNinePatchSprite wyNinePatchSprite\endlink对象，则其会根据
	 * 可视范围进行相应的拉伸。
	 *
	 * @param thumb 用作垂直滚动条的\link wyNode wyNode\endlink对象, NULL表示要去掉垂直滚动条
	 */
	void setVerticalThumb(wyNode* thumb);

	/**
	 * 设置如果多久无滚动就淡出滚动条，缺省是0. 0值表示不淡出滚动条。
	 *
	 * @param time 淡出之前的无滚动时间, 单位秒
	 */
	void setThumbFadeOutTime(float time) { m_fadeOutTime = time; }

	/**
	 * 得到淡出之前的无滚动时间
	 *
	 * @return 淡出之前的无滚动时间
	 */
	float getThumbFadeOutTime() { return m_fadeOutTime; }

	/**
	 * 设置可滚动区域左边的留白大小
	 *
	 * @param m 可滚动区域左边的留白大小
	 */
	void setLeftMargin(float m) { m_leftMargin = m; }

	/**
	 * 获得可滚动区域左边的留白大小
	 *
	 * @return 可滚动区域左边的留白大小
	 */
	float getLeftMargin() { return m_leftMargin; }
	
	/**
	 * 设置可滚动区域右边的留白大小
	 *
	 * @param m 可滚动区域右边的留白大小
	 */
	void setRightMargin(float m) { m_rightMargin = m; }

	/**
	 * 获得可滚动区域右边的留白大小
	 *
	 * @return 可滚动区域右边的留白大小
	 */
	float getRightMargin() { return m_rightMargin; }

	/**
	 * 设置可滚动区域上边的留白大小
	 *
	 * @param m 可滚动区域上边的留白大小
	 */
	void setTopMargin(float m) { m_topMargin = m; }

	/**
	 * 获得可滚动区域上边的留白大小
	 *
	 * @return 可滚动区域上边的留白大小
	 */
	float getTopMargin() { return m_topMargin; }

	/**
	 * 设置可滚动区域下边的留白大小
	 *
	 * @param m 可滚动区域下边的留白大小
	 */
	void setBottomMargin(float m) { m_bottomMargin = m; }

	/**
	 * 获得可滚动区域下边的留白大小
	 *
	 * @return 可滚动区域下边的留白大小
	 */
	float getBottomMargin() { return m_bottomMargin; }
	
	/**
	 * 获得当前的x方向滚动位置, 这个值的范围是从0到最大可滚动位置
	 *
	 * @return 当前的x方向滚动位置
	 */
	float getOffsetX() { return m_xOffset; }

	/**
	 * 获得当前的y方向滚动位置, 这个值的范围是从0到最大可滚动位置
	 *
	 * @return 当前的y方向滚动位置
	 */
	float getOffsetY() { return m_yOffset; }
	
	/**
	 * 设置当前的x方向位置，这个值的范围从0到最大可滚动位置
	 *
	 * @param x x位置，如果值不合法则不做任何事
	 */
	void setOffsetX(float x);

	/**
	 * 设置当前的y方向位置，这个值的范围从0到最大可滚动位置
	 *
	 * @param y y位置，如果值不合法则不做任何事
	 */
	void setOffsetY(float y);

	/**
	 * 判断当前x方向滚动位置是否已经是最右
	 *
	 * @return true表示x方向已经滚到了最右边
	 */
	bool isAtXEnd();

	/**
	 * 判断当前y方向是否已经滚动到底部
	 *
	 * @return true表示y方向已经滚动到底部
	 */
	bool isAtYEnd();
	
	/**
	 * 设置回调
	 *
	 * @param callback \link wyScrollableLayerCallback wyScrollableLayerCallback\endlink 结构指针, callback的内容
	 * 		会被复制，因此\link wyScrollableLayer wyScrollableLayer\endlink不会负责释放该指针。如果指针为NULL，表示清
	 * 		除之前设置的回调
	 * @param data 附加数据指针, \link wyScrollableLayer wyScrollableLayer\endlink不会负责释放该指针
	 */
	void setCallback(wyScrollableLayerListener* callback);
};

#endif // __wyScrollableLayer_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyVirtualJoystick_h__

/*
 * 虚拟摇杆的方向定义
 */

#define VJD_CENTER -1
#define VJD_NORTH -2
#define VJD_SOUTH -3
#define VJD_EAST -4
#define VJD_WEST -5
#define VJD_NORTH_EAST -6
#define VJD_NORTH_WEST -7
#define VJD_SOUTH_EAST -8
#define VJD_SOUTH_WEST -9

/**
 * @typedef wyVirtualJoystickEventStyle
 *
 * 摇杆触发的事件类型
 */
typedef enum {
	/**
	 * 摇杆将触发5个方向的事件, 即东南西北中. 这是缺省的类型
	 */
	VJS_FIVE_DIRECTIONS,

	/**
	 * 摇杆将触发9个方向的事件, 即东南西北中, 以及东南, 东北, 西南, 西北
	 */
	VJS_NINE_DIRECTIONS,

	/**
	 * 摇杆将触发360度方向的事件
	 */
	VJS_FULL_DIRECTIONS
} wyVirtualJoystickEventStyle;

/**
 * @typedef wyVirtualJoystickCallback
 *
 * 虚拟摇杆节点的回调接口定义
 */
typedef struct wyVirtualJoystickCallback {
} wyVirtualJoystickCallback;

/**
 * @class wyVirtualJoystick
 *
 * 虚拟摇杆类. 虚拟摇杆是一个组合式节点, 创建时需要提供两个节点, 一个代表虚拟摇杆的背景盘,
 * 一个代表摇杆. 通过设置, 可以指定摇杆触发5方向, 或9方向, 或360度方向的事件. 这两个节点都会
 * 被加为\link wyVirtualJoystick wyVirtualJoystick\endlink, 并且摇杆节点会居中放置.
 *
 * \par
 * 摇杆节点可以移动的范围是可以设置的, 范围呈圆形, 因此设置一个半径即可.
 */
class wyVirtualJoystick : public wyNode {
public:
	/**
	 * 静态构造函数, 创建后, \link wyVirtualJoystick wyVirtualJoystick\endlink节点的大小将
	 * 设置成为正好包含背景和摇杆节点
	 *
	 * @param bg 背景节点, 可以为NULL
	 * @param rocker 摇杆节点, 可以为NULL
	 * @return \link wyVirtualJoystick wyVirtualJoystick\endlink
	 */
	static wyVirtualJoystick* make(wyNode* bg, wyNode* rocker);

	virtual ~wyVirtualJoystick();

	/// @see wyNode::touchesBegan
	virtual bool touchesBegan(wyMotionEvent& e);

	/// @see wyNode::touchesMoved
	virtual bool touchesMoved(wyMotionEvent& e);

	/// @see wyNode::touchesEnded
	virtual bool touchesEnded(wyMotionEvent& e);

	/// @see wyNode::touchesCancelled
	virtual bool touchesCancelled(wyMotionEvent& e);

	/*
	 * setter and getter
	 */

	/**
	 * 得到事件触发类型
	 *
	 * @return 事件触发类型
	 */
	wyVirtualJoystickEventStyle getEventStyle() { return m_eventStyle; }

	/**
	 * 设置事件触发类型
	 *
	 * @param style 事件触发类型
	 */
	void setEventStyle(wyVirtualJoystickEventStyle style) { m_eventStyle = style; }

	/**
	 * 设置是否触摸事件结束时自动把摇杆节点置回中心
	 *
	 * @param flag true表示当触摸事件结束时自动把摇杆节点置回中心, 缺省是true
	 */
	void setAutoReset(bool flag) { m_autoReset = flag; }

	/**
	 * 是否触摸事件结束时自动把摇杆节点置回中心
	 *
	 * @return true表示当触摸事件结束时自动把摇杆节点置回中心, 缺省是true
	 */
	bool isAutoReset() { return m_autoReset; }

	/**
	 * 设置回调
	 *
	 * @param callback \link wyVirtualJoystickCallback wyVirtualJoystickCallback\endlink 结构指针, callback的内容
	 * 		会被复制，因此\link wyVirtualJoystick wyVirtualJoystick\endlink不会负责释放该指针。如果指针为NULL，表示清
	 * 		除之前设置的回调
	 * @param data 附加数据指针, \link wyVirtualJoystick wyVirtualJoystick\endlink不会负责释放该指针
	 */
	void setCallback(wyVirtualJoystickCallback* callback, void* data);
};

#endif // __wyVirtualJoystick_h__

/*
 * Copyright (c) 2010 WiYun Inc.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef __wyToast_h__

/**
 * @class wyToast
 *
 * \if English
 * A UI component behaves like Android Toast control. It consists of background and content
 * node, so it can display anything. Background node is better to be a scalable node, such as
 * \link wyNinePatchSprite wyNinePatchSprite\endlink
 * \else
 * 类似于Android的toast控件的节点, 由一个背景和内容两个节点组成. 因此它不限于只能显示文字, 内容节点可以
 * 为任意类型. 背景节点最好是一个可以拉伸的节点, 比如\link wyNinePatchSprite wyNinePatchSprite\endlink.
 * \endif
 */
class wyToast : public wyNode {

public:
	virtual ~wyToast();

	/**
	 * \if English
	 * Create a toast with background and content node
	 *
	 * @param bg background node
	 * @param content content node
	 * @param duration duration in seconds
	 * \else
	 * 创建一个toast节点, 指定背景和内容节点
	 *
	 * @param bg 背景节点
	 * @param content 内容节点
	 * @param duration 持续显示时间, 时间到后会渐渐消失
	 * \endif
	 */
	static wyToast* make(wyNode* bg, wyNode* content, float duration);

	/**
	 * \if English
	 * Create a toast with background node, and content text, the text
	 * will be assigned to a \link wyLabel wyLabel\endlink
	 *
	 * @param bg background node
	 * @param text content text string
	 * @param duration duration in seconds
	 * \else
	 * 创建一个toast, 仅指定背景节点和内容文字. 文字会被赋于一个\link wyLabel wyLabel\endlink节点.
	 *
	 * @param bg 背景节点
	 * @param text 内容文字
	 * @param duration 持续显示时间, 时间到后会渐渐消失
	 * \endif
	 */
	static wyToast* make(wyNode* bg, const char* text, float duration);

	/**
	 * \if English
	 * Create a toast with content text. The background will be set to default style
	 *
	 * @param text content text
	 * @param duration duration in seconds
	 * \else
	 * 创建一个Toast节点, 只指定内容文字. 背景会设置成缺省样式
	 *
	 * @param text 内容文字
	 * @param duration 持续显示时间, 时间到后会渐渐消失
	 * \endif
	 */
	static wyToast* make(const char* text, float duration);

	/**
	 * \if English
	 * Show this toast
	 *
	 * @param immediately true means the toast should be visible right now, or false
	 * 		means it will be shown after previous toast is disappeared, default is false
	 * \else
	 * 显示这个toast
	 *
	 * @param immediately true表示立刻显示这个toast. false表示等它之前一个toast消失之后再显示,
	 * 		缺省是false
	 */
	void show(bool immediately = false);

	/**
	 * \if English
	 * Get background node
	 * \else
	 * 得到背景节点
	 * \endif
	 */
	wyNode* getBackground() { return m_bg; }

	/**
	 * \if English
	 * Get content node
	 * \else
	 * 得到内容节点
	 * \endif
	 */
	wyNode* getContent() { return m_content; }

	/**
	 * \if English
	 * Set margin between content and background node.
	 * \else
	 * 设置内容节点和背景节点边界的距离
	 * \endif
	 */
	void setMargin(float top, float left, float right, float bottom);

	/**
	 * \if English
	 * Get left margin
	 * \else
	 * 得到左边空隙
	 * \endif
	 */
	float getLeftMargin() { return m_leftMargin; }

	/**
	 * \if English
	 * Get right margin
	 * \else
	 * 得到右边空隙
	 * \endif
	 */
	float getRightMargin() { return m_rightMargin; }

	/**
	 * \if English
	 * Get top margin
	 * \else
	 * 得到上边空隙
	 * \endif
	 */
	float getTopMargin() { return m_topMargin; }

	/**
	 * \if English
	 * Get bottom margin
	 * \else
	 * 得到下边空隙
	 * \endif
	 */
	float getBottomMargin() { return m_bottomMargin; }

	/**
	 * \if English
	 * Set desired position where toast will be shown. If not set,
	 * toast will be placed in (wyDevice::winWidth / 2, wyDevice::winHeight * 4 / 5)
	 * \else
	 * 设置toast出现的位置, 如果不设置. 则缺省会放在屏幕中间偏下的位置, 具体坐标是:
	 * (wyDevice::winWidth / 2, wyDevice::winHeight * 4 / 5)
	 * \endif
	 */
	void setToastPosition(float x, float y);
};

#endif // __wyToast_h__
